<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 赛博粒子核心</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000510; font-family: 'Segoe UI', sans-serif; }
        
        /* 视频预览窗口 - 加上发光边框 */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            z-index: 10;
            background: #000;
        }
        #input-video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }

        /* 状态文字 */
        #status-display {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            z-index: 5;
        }
        .gesture-name {
            font-size: 80px;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 10px;
            transition: all 0.3s ease;
        }
        /* 激活时的文字发光 */
        .active-text {
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 30px #00ffff;
            transform: scale(1.2);
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000510; display: flex; align-items: center; justify-content: center;
            color: #00ffff; z-index: 100;
        }
    </style>

    <!-- MediaPipe 依赖 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader"><h1>系统启动中...</h1></div>
    
    <div id="status-display">
        <div id="gesture-name" class="gesture-name">SYSTEM READY</div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <!-- Three.js 依赖 -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 核心配置 ---
        const CONFIG = {
            count: 15000,         // 粒子总数 (减少数量以换取单个粒子的高质量渲染)
            coreSize: 8,          // 核心球体半径
            scatterSize: 60,      // 散布范围
            baseColor: new THREE.Color('#0055ff'), // 深蓝
            glowColor: new THREE.Color('#00ffff'), // 青色高光
        };

        let scene, camera, renderer, material;
        let particles, geometry;
        let time = 0;

        // 状态变量
        let state = {
            scale: 1.0,           // 整体膨胀系数
            dispersal: 0.0,       // 炸散程度 (0 = 聚集, 1 = 炸飞)
            coreTightness: 1.0,   // 核心紧密度
            rotationSpeed: 0.2,   // 旋转速度
            gestureName: ''
        };
        let targetState = { ...state };

        // --- 1. 场景初始化 ---
        function init() {
            scene = new THREE.Scene();
            // 背景不是纯黑，而是带有极淡的蓝色雾气，增加空间感
            scene.fog = new THREE.FogExp2(0x000510, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // 开启这种混合模式有助于产生强烈的光感
            renderer.setClearColor(0x000510);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            createParticles();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 2. 创建超亮粒子系统 ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const randoms = []; // 用于动画的随机偏移
            const sizes = [];   // 粒子基础大小
            const colors = [];  // 粒子颜色

            const color1 = CONFIG.baseColor;
            const color2 = CONFIG.glowColor;

            for (let i = 0; i < CONFIG.count; i++) {
                // 两种分布模式：
                // 30% 是核心致密球体 (高亮，小而密)
                // 70% 是周围漂浮的尘埃 (大光斑，范围广)
                const isCore = Math.random() < 0.35; 

                let x, y, z, r;
                
                if (isCore) {
                    // 核心：高斯分布，聚集在中心
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    r = CONFIG.coreSize * Math.pow(Math.random(), 0.5); // 稍微实心一点
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    sizes.push(Math.random() * 1.5 + 0.5); // 核心粒子较小但密集
                    
                    // 核心颜色偏青白
                    colors.push(color2.r, color2.g, color2.b); 
                } else {
                    // 外部：均匀散布在更大的空间
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    r = CONFIG.coreSize + Math.random() * (CONFIG.scatterSize - CONFIG.coreSize);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);

                    // 外部粒子：有大有小，模拟景深光斑
                    // 极少数粒子特别大（Bokeh效果）
                    if (Math.random() < 0.1) {
                        sizes.push(Math.random() * 10 + 5); 
                    } else {
                        sizes.push(Math.random() * 3 + 1);
                    }

                    // 外部颜色偏深蓝，带一点青色混合
                    const mixRatio = Math.random();
                    colors.push(
                        color1.r * mixRatio + color2.r * (1-mixRatio),
                        color1.g * mixRatio + color2.g * (1-mixRatio),
                        color1.b * mixRatio + color2.b * (1-mixRatio)
                    );
                }

                positions.push(x, y, z);
                randoms.push(Math.random(), Math.random(), Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // --- 关键：自定义 Shader 材质 ---
            // 这比普通 PointsMaterial 能做更多特效
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 1.0 },       // 手势控制：整体缩放
                    uDispersal: { value: 0.0 },   // 手势控制：炸开程度
                    uTexture: { value: getTexture() }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uScale;
                    uniform float uDispersal;
                    attribute float size;
                    attribute vec3 aRandom;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = color;
                        
                        vec3 pos = position;

                        // 1. 基础呼吸动画
                        pos += sin(uTime * 2.0 + aRandom * 10.0) * 0.2;

                        // 2. 爆炸效果 (Dispersal)
                        // 沿着法线方向炸开
                        vec3 dir = normalize(pos);
                        pos += dir * uDispersal * 60.0 * aRandom.x; // 随机炸得更远

                        // 3. 整体缩放 (Scale)
                        pos *= uScale;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        // 4. 大小衰减 (Size Attenuation)
                        // 距离相机越近越大，模拟景深
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        
                        // 限制最大光斑
                        gl_PointSize = clamp(gl_PointSize, 0.0, 150.0);

                        // 5. 根据距离调整透明度
                        float dist = length(mvPosition.xyz);
                        vAlpha = smoothstep(100.0, 0.0, dist); // 远处渐隐
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTexture;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // 获取纹理颜色
                        vec4 texColor = texture2D(uTexture, gl_PointCoord);
                        
                        // 如果纹理太黑（透明部分），直接丢弃，优化性能
                        if (texColor.a < 0.05) discard;

                        // 颜色增强：让中心更亮白
                        vec3 finalColor = vColor * 2.0; 

                        gl_FragColor = vec4(finalColor, vAlpha * texColor.a);
                    }
                `,
                blending: THREE.AdditiveBlending, // 加法混合，关键！产生发光叠加效果
                depthWrite: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // 生成高斯模糊的光斑纹理
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 绘制辉光
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255, 255, 255, 1)'); // 中心极亮
            g.addColorStop(0.3, 'rgba(100, 200, 255, 0.5)');
            g.addColorStop(0.5, 'rgba(0, 50, 100, 0.2)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // --- 3. 手势逻辑 ---
        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20].map(i => landmarks[i]);
            
            // 计算指尖到手腕的平均距离
            let avgDist = 0;
            tips.forEach(t => {
                avgDist += Math.sqrt(Math.pow(t.x-wrist.x, 2) + Math.pow(t.y-wrist.y, 2) + Math.pow(t.z-wrist.z, 2));
            });
            avgDist /= 5;

            // 握拳：所有手指缩成一团
            if (avgDist < 0.15) return 'FIST';
            
            // 张开：所有手指伸展
            if (avgDist > 0.35) return 'OPEN';

            // 指向：仅食指伸直 (简单判断：食指远，小指近)
            const indexDist = Math.sqrt(Math.pow(tips[1].x-wrist.x, 2) + Math.pow(tips[1].y-wrist.y, 2));
            const pinkyDist = Math.sqrt(Math.pow(tips[4].x-wrist.x, 2) + Math.pow(tips[4].y-wrist.y, 2));
            if (indexDist > 0.3 && pinkyDist < 0.2) return 'POINT';

            return 'IDLE';
        }

        function updateState() {
            // 平滑过渡 (Lerp)
            const speed = 0.05;
            state.scale += (targetState.scale - state.scale) * speed;
            state.dispersal += (targetState.dispersal - state.dispersal) * speed;
            
            // 更新 Shader Uniforms
            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uScale.value = state.scale;
                material.uniforms.uDispersal.value = state.dispersal;
            }

            // UI 文字更新
            const ui = document.getElementById('gesture-name');
            ui.innerText = state.gestureName;
            if (state.gestureName !== 'SYSTEM READY' && state.gestureName !== '') {
                ui.classList.add('active-text');
            } else {
                ui.classList.remove('active-text');
            }
        }

        // --- 4. 循环与 MediaPipe ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            updateState();
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            if (!window.Hands) { setTimeout(initMediaPipe, 100); return; }

            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            
            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const gesture = detectGesture(results.multiHandLandmarks[0]);
                    
                    if (gesture === 'OPEN') {
                        targetState.scale = 1.2;       // 稍微变大
                        targetState.dispersal = 1.0;   // 剧烈炸开！
                        state.gestureName = "DISPERSE";
                    } else if (gesture === 'FIST') {
                        targetState.scale = 0.1;       // 极度浓缩
                        targetState.dispersal = 0.0;   // 聚拢
                        state.gestureName = "COLLAPSE";
                    } else if (gesture === 'POINT') {
                        targetState.scale = 1.0;
                        targetState.dispersal = 0.2;   // 轻微浮动
                        state.gestureName = "FOCUS";
                        // 指向时旋转加速
                        particles.rotation.y += 0.02; 
                        particles.rotation.x += 0.01;
                    } else {
                        targetState.scale = 1.0;
                        targetState.dispersal = 0.0;
                        state.gestureName = "";
                    }
                } else {
                    // 无手势，恢复默认呼吸
                    targetState.scale = 1.0;
                    targetState.dispersal = 0.1; // 默认带一点点散开，比较自然
                    state.gestureName = "";
                }
            });

            const cam = new window.Camera(document.getElementById('input-video'), {
                onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
                width: 320, height: 240
            });
            cam.start().then(() => document.getElementById('loader').style.display = 'none');
        }

        init();
        animate();
        initMediaPipe();

    </script>
</body>
</html>
