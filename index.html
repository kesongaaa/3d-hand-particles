<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ether Tarot: AI Divination</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Cinzel', serif; color: #e0d6ff; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* å¼•å…¥å­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300&display=swap');

        /* è§†é¢‘æµ (éšè—ä½†å¿…é¡»å­˜åœ¨) */
        #input-video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: 0; }

        /* UI å±‚ */
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* é¡¶éƒ¨ HUD */
        .hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .mode-switch { pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px); font-size: 12px; }
        .history-panel { width: 200px; max-height: 150px; overflow-y: auto; text-align: right; font-size: 12px; opacity: 0.8; }
        .history-item { margin-bottom: 5px; border-right: 2px solid #a892ff; padding-right: 8px; }

        /* ä¸­é—´å¡ç‰Œå«ä¹‰ */
        #meaning-display { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; width: 80%; opacity: 0; transition: opacity 1s; pointer-events: none;
            text-shadow: 0 0 10px black;
        }
        #card-title { font-size: 24px; color: #ffd700; margin-bottom: 10px; font-weight: bold; text-transform: uppercase; }
        #card-desc { font-size: 16px; line-height: 1.5; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; backdrop-filter: blur(5px); }

        /* åº•éƒ¨æŒ‡ç¤º */
        .hud-bottom { padding: 20px; text-align: center; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); }
        .status-text { font-size: 14px; letter-spacing: 2px; color: #a892ff; margin-bottom: 10px; }
        .controls-hint { font-size: 10px; opacity: 0.6; display: flex; justify-content: center; gap: 15px; }
        .hint-icon { font-weight: bold; color: #ffd700; }

        /* å¯åŠ¨å±å¹• */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #ffd700;
        }
        #start-btn {
            margin-top: 30px; padding: 15px 40px; font-size: 18px;
            background: transparent; border: 2px solid #ffd700; color: #ffd700;
            cursor: pointer; transition: 0.3s; font-family: 'Cinzel', serif;
        }
        #start-btn:hover { background: #ffd700; color: #000; box-shadow: 0 0 20px #ffd700; }

    </style>
    
    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input-video" playsinline muted autoplay></video>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin:0;">ETHER TAROT</h1>
        <p style="font-size: 14px; opacity: 0.7; letter-spacing: 3px;">THE FATE IN YOUR HANDS</p>
        <button id="start-btn" onclick="initApp()">âœ¦ å¼€å§‹å åœ âœ¦</button>
        <p style="font-size: 10px; margin-top:20px; opacity: 0.5;">å»ºè®®ä½¿ç”¨ Safari æµè§ˆå™¨å¹¶å…è®¸æ‘„åƒå¤´</p>
    </div>

    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <button class="mode-switch" id="mode-btn" onclick="toggleInputMode()">ğŸ– æ‰‹åŠ¿æ¨¡å¼</button>
            <div class="history-panel" id="history-list">
                <!-- å†å²è®°å½• -->
            </div>
        </div>

        <div id="meaning-display">
            <div id="card-title"></div>
            <div id="card-desc"></div>
        </div>

        <div class="hud-bottom">
            <div class="status-text" id="status-text">ç­‰å¾…è¿æ¥çµç•Œ...</div>
            <div class="controls-hint" id="gesture-hints">
                <span><span class="hint-icon">ğŸ‘Œ æåˆ</span> æŠ“å–æŸ¥çœ‹</span>
                <span><span class="hint-icon">âœŠ æ¡æ‹³</span> ç¡®è®¤å¬å”¤</span>
                <span><span class="hint-icon">âœ‹ å¼ å¼€</span> å¯»æ‰¾ç‰Œçµ</span>
            </div>
            <div class="controls-hint" id="mouse-hints" style="display:none;">
                <span><span class="hint-icon">ğŸ–±ï¸ æŒ‰ä½</span> æŠ“å–æŸ¥çœ‹</span>
                <span><span class="hint-icon">ğŸ–±ï¸ åŒå‡»</span> ç¡®è®¤å¬å”¤</span>
            </div>
        </div>
    </div>

<script>
    // --- 0. å¡”ç½—ç‰Œæ•°æ® (å¤§é˜¿å¡çº³ 22 å¼  - Rider Waite) ---
    const TAROT_DATA = [
        { name: "The Fool", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹ï¼Œå†’é™©ï¼Œå¤©çœŸï¼Œæ½œåŠ›", rev: "é²è½ï¼Œè½»ç‡ï¼Œé£é™©ï¼Œæ„šè ¢" },
        { name: "The Magician", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "æ„å¿—åŠ›ï¼Œåˆ›é€ ï¼ŒæŒæ¡ï¼ŒæŠ€èƒ½", rev: "æ“çºµï¼Œè®¡åˆ’ä¸å‘¨ï¼Œæ½œèƒ½æœªå‘" },
        { name: "The High Priestess", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜ï¼Œå†…åœ¨å£°éŸ³", rev: "ç§˜å¯†è¢«æ­éœ²ï¼Œå‹æŠ‘ç›´è§‰" },
        { name: "The Empress", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶ï¼Œæ¯æ€§ï¼Œè‡ªç„¶ï¼Œåˆ›é€ åŠ›", rev: "ä¾èµ–ï¼Œåˆ›é€ åŠ›å—é˜»ï¼Œç©ºè™š" },
        { name: "The Emperor", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨ï¼Œç»“æ„ï¼Œæ§åˆ¶ï¼Œçˆ¶æ€§", rev: "æš´æ”¿ï¼ŒåƒµåŒ–ï¼Œç¼ºä¹çºªå¾‹" },
        { name: "The Hierophant", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿï¼Œä¿¡ä»°ï¼Œä»ä¼—ï¼Œæ•™è‚²", rev: "åå›ï¼Œéå¸¸è§„ï¼Œæ–°çš„ä¿¡ä»°" },
        { name: "The Lovers", url: "https://upload.wikimedia.org/wikipedia/commons/3/3a/RWS_Tarot_06_Lovers.jpg", up: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©", rev: "ä¸å’Œè°ï¼Œå¤±è¡¡ï¼Œé”™è¯¯çš„é€‰æ‹©" },
        { name: "The Chariot", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼Œèƒœåˆ©ï¼Œè¡ŒåŠ¨", rev: "å¤±æ§ï¼Œä¾µç•¥ï¼Œç¼ºä¹æ–¹å‘" },
        { name: "Strength", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè€å¿ƒï¼ŒåŒæƒ…", rev: "è½¯å¼±ï¼Œè‡ªæˆ‘æ€€ç–‘ï¼Œç”Ÿç¡¬" },
        { name: "The Hermit", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "åçœï¼Œå¯»æ‰¾çœŸç†ï¼Œå†…åœ¨æŒ‡å¼•", rev: "å­¤ç«‹ï¼Œå­¤ç‹¬ï¼Œé€€ç¼©" },
        { name: "Wheel of Fortune", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "æ”¹å˜ï¼Œå¾ªç¯ï¼Œå‘½è¿ï¼Œè½¬æŠ˜ç‚¹", rev: "åè¿æ°”ï¼Œé˜»åŠ›ï¼Œå¾ªç¯ä¸­æ–­" },
        { name: "Justice", url: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", up: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ", rev: "ä¸å…¬ï¼Œç¼ºä¹è´£ä»»ï¼Œä¸è¯šå®" },
        { name: "The Hanged Man", url: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", up: "æš‚åœï¼ŒæŠ•é™ï¼Œæ–°è§†è§’ï¼Œç‰ºç‰²", rev: "æ‹–å»¶ï¼ŒæŠµæŠ—ï¼Œåœæ»" },
        { name: "Death", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸï¼Œè½¬å˜ï¼Œé‡ç”Ÿï¼Œè¿‡æ¸¡", rev: "æŠµæŠ—æ”¹å˜ï¼Œæ— æ³•æ”¾æ‰‹" },
        { name: "Temperance", url: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", up: "å¹³è¡¡ï¼ŒèŠ‚åˆ¶ï¼Œè€å¿ƒï¼Œç›®æ ‡", rev: "å¤±è¡¡ï¼Œè¿‡åº¦ï¼Œç¼ºä¹å’Œè°" },
        { name: "The Devil", url: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", up: "æŸç¼šï¼Œç‰©è´¨ä¸»ä¹‰ï¼Œæˆç˜¾ï¼Œé˜´å½±", rev: "é‡Šæ”¾ï¼Œæ‰“ç ´æ·é”ï¼Œæ¢å¤åŠ›é‡" },
        { name: "The Tower", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "çªç„¶çš„å˜åŒ–ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º", rev: "é¿å…ç¾éš¾ï¼Œæ¨è¿Ÿæ”¹å˜" },
        { name: "The Star", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›ï¼Œä¿¡ä»°ï¼Œç›®çš„ï¼Œæ›´æ–°", rev: "ç»æœ›ï¼Œç¼ºä¹ä¿¡ä»°ï¼Œæ²®ä¸§" },
        { name: "The Moon", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§ï¼Œå‹æŠ‘æƒ…ç»ªï¼Œæ··ä¹±" },
        { name: "The Sun", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹ï¼ŒæˆåŠŸï¼Œç§¯æï¼Œæ´»åŠ›", rev: "æš‚æ—¶çš„æ¶ˆæï¼Œç¼ºä¹æ¸…æ™°" },
        { name: "Judgement", url: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", up: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…åœ¨å¬å”¤ï¼Œå®½æ•", rev: "è‡ªæˆ‘æ€€ç–‘ï¼Œæ‹’ç»å¬å”¤" },
        { name: "The World", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œæ—…è¡Œ", rev: "æœªå®Œæˆï¼Œç¼ºä¹å°é—­ï¼Œæ·å¾„" }
    ];

    // --- 1. å…¨å±€å˜é‡ä¸é…ç½® ---
    let inputMode = 'HAND'; // 'HAND' or 'MOUSE'
    let state = 'WAITING'; // WAITING, DRAWN, INSPECTING, CONFIRMED
    let deck = [...TAROT_DATA];
    let currentCardData = null;
    let isReversed = false;

    // Three.js æ ¸å¿ƒ
    let scene, camera, renderer;
    let cardMesh, ashSystem;
    let raycaster = new THREE.Raycaster();
    
    // äº¤äº’å˜é‡
    let pointer = new THREE.Vector2(); // å½’ä¸€åŒ–åæ ‡
    let rawPointer = { x: 0, y: 0 }; // å±å¹•åƒç´ åæ ‡
    let inputAction = { 
        isPinching: false, 
        isFist: false, 
        isPointing: false,
        active: false 
    };

    // ç‰©ç†å¹³æ»‘
    let targetPos = new THREE.Vector3(0, -5, 0);
    let targetRot = new THREE.Quaternion();
    
    // æè´¨åŠ è½½å™¨
    const textureLoader = new THREE.TextureLoader();
    // é»˜è®¤ç‰ŒèƒŒ
    const backTexture = textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Card_back_05.svg/307px-Card_back_05.svg.png');

    // --- 2. åˆå§‹åŒ– Three.js ---
    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 10;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffd700, 1.5);
        spotLight.position.set(5, 10, 5);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);

        const purpleLight = new THREE.PointLight(0xa892ff, 1, 20);
        purpleLight.position.set(-5, 0, 5);
        scene.add(purpleLight);
    }

    // --- 3. å¡ç‰Œé€»è¾‘ ---
    
    function createCardMesh() {
        const geometry = new THREE.BoxGeometry(3, 5, 0.05);
        // æè´¨å ä½
        const materials = [
            new THREE.MeshStandardMaterial({ color: 0x111111 }), // Right
            new THREE.MeshStandardMaterial({ color: 0x111111 }), // Left
            new THREE.MeshStandardMaterial({ color: 0x111111 }), // Top
            new THREE.MeshStandardMaterial({ color: 0x111111 }), // Bottom
            new THREE.MeshStandardMaterial({ color: 0x222222 }), // Front (initially blank)
            new THREE.MeshStandardMaterial({ map: backTexture }) // Back
        ];
        
        cardMesh = new THREE.Mesh(geometry, materials);
        cardMesh.visible = false; // åˆå§‹éšè—
        scene.add(cardMesh);
    }

    function spawnNewCard() {
        if (deck.length === 0) {
            document.getElementById('status-text').innerText = "å‘½è¿ä¹‹è½®å·²è½¬å®Œä¸€åœˆ (ç‰Œåº“ç©º)";
            return;
        }

        // éšæœºæŠ½ç‰Œ
        const index = Math.floor(Math.random() * deck.length);
        currentCardData = deck.splice(index, 1)[0];
        
        // éšæœºæ­£é€†ä½
        isReversed = Math.random() < 0.3; // 30% å‡ ç‡é€†ä½

        // åŠ è½½è´´å›¾
        textureLoader.load(currentCardData.url, (tex) => {
            // è®¾ç½®å¡ç‰Œæ­£é¢ (æè´¨ç´¢å¼•4)
            cardMesh.material[4].map = tex;
            cardMesh.material[4].needsUpdate = true;
        }, undefined, () => {
            // å¤±è´¥å›é€€
            cardMesh.material[4].color.set(0x330000); 
        });

        // é‡ç½®ä½ç½®
        cardMesh.position.set(0, -10, 0); // ä»ä¸‹æ–¹å‡èµ·
        cardMesh.rotation.set(0, Math.PI, 0); // èƒŒé¢æœä¸Š
        cardMesh.scale.set(1, 1, 1);
        cardMesh.visible = true;

        state = 'DRAWN';
        updateUI('DRAWN');
    }

    // --- 4. ç°çƒ¬ç²’å­ç‰¹æ•ˆ ---
    const particleCount = 2000;
    const ashGeo = new THREE.BufferGeometry();
    const ashPos = new Float32Array(particleCount * 3);
    const ashVel = new Float32Array(particleCount * 3);
    const ashLife = new Float32Array(particleCount);
    
    // åˆå§‹åŒ–ç©ºç²’å­
    ashGeo.setAttribute('position', new THREE.BufferAttribute(ashPos, 3));
    const ashMat = new THREE.PointsMaterial({
        color: 0xffd700,
        size: 0.15,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    ashSystem = new THREE.Points(ashGeo, ashMat);
    scene.add(ashSystem);

    function triggerAshEffect() {
        const center = cardMesh.position.clone();
        
        // ç”Ÿæˆç²’å­å¡«å……å¡ç‰Œä½“ç§¯
        for(let i=0; i<particleCount; i++) {
            const idx = i*3;
            // åœ¨å¡ç‰ŒçŸ©å½¢èŒƒå›´å†…éšæœºåˆ†å¸ƒ
            const xSpread = (Math.random() - 0.5) * 3;
            const ySpread = (Math.random() - 0.5) * 5;
            
            // è€ƒè™‘å¡ç‰Œæ—‹è½¬ï¼Œç®€å•èµ·è§ç›´æ¥ç”¨ä¸–ç•Œåæ ‡åç§»
            ashPos[idx] = center.x + xSpread;
            ashPos[idx+1] = center.y + ySpread;
            ashPos[idx+2] = center.z + (Math.random() - 0.5) * 0.1;

            // é€Ÿåº¦ï¼šå‘ä¸Šé£˜åŠ¨ + å™ªå£°æ¹æµ
            ashVel[idx] = (Math.random() - 0.5) * 0.1; // X æ¼‚ç§»
            ashVel[idx+1] = Math.random() * 0.1 + 0.05; // Y å‘ä¸Š
            ashVel[idx+2] = (Math.random() - 0.5) * 0.1; // Z æ¼‚ç§»

            ashLife[i] = 1.0; // ç”Ÿå‘½å€¼ 1.0 -> 0.0
        }

        ashMat.opacity = 0.8;
        ashGeo.attributes.position.needsUpdate = true;
        
        // éšè—åŸå¡ç‰Œ
        cardMesh.visible = false;
        state = 'DISINTEGRATING';
        
        // è®°å½•å†å²
        addToHistory();
    }

    function updateAsh() {
        if(state !== 'DISINTEGRATING') return;

        let activeParticles = 0;
        const positions = ashGeo.attributes.position.array;

        for(let i=0; i<particleCount; i++) {
            if(ashLife[i] > 0) {
                const idx = i*3;
                
                // ç®€å•çš„æ¹æµæ¨¡æ‹Ÿ
                ashVel[idx] += (Math.random()-0.5) * 0.005;
                
                positions[idx] += ashVel[idx];
                positions[idx+1] += ashVel[idx+1];
                positions[idx+2] += ashVel[idx+2];

                ashLife[i] -= 0.015; // è¡°å‡
                activeParticles++;
            }
        }
        
        ashMat.opacity *= 0.98; // æ•´ä½“æ·¡å‡º
        ashGeo.attributes.position.needsUpdate = true;

        if (ashMat.opacity < 0.01) {
            state = 'WAITING';
            updateUI('WAITING');
            spawnNewCard(); // è‡ªåŠ¨ç”Ÿæˆä¸‹ä¸€å¼ 
        }
    }

    // --- 5. ä¸»å¾ªç¯ä¸äº¤äº’é€»è¾‘ ---
    function animate() {
        requestAnimationFrame(animate);
        
        const dt = 0.016;

        // çŠ¶æ€æœºé€»è¾‘
        if (state === 'DRAWN') {
            // å¡ç‰Œæ‚¬æµ®åœ¨åˆå§‹ä½ç½®
            targetPos.set(0, -2, 0); 
            // ç¼“æ…¢æ—‹è½¬å±•ç¤ºèƒŒé¢
            cardMesh.rotation.y += 0.01;
            
            // å¦‚æœæ£€æµ‹åˆ°æ‰‹åŠ¿/é¼ æ ‡æåˆ
            if (inputAction.isPinching) {
                // ç®€å•çš„å°„çº¿æ£€æµ‹ï¼šå¦‚æœæ‰‹åœ¨å¡ç‰Œé™„è¿‘
                // è¿™é‡Œç®€åŒ–ï¼šåªæœ‰ä¸€å¼ ç‰Œï¼Œåªè¦æŠ“å–åŠ¨ä½œå‘ç”Ÿä¸”è·ç¦»ä¸­å¿ƒè¿‘å°±å¸é™„
                const dist = pointer.distanceTo(new THREE.Vector2(0, -0.2)); // å½’ä¸€åŒ–ä¸­å¿ƒåä¸‹
                if (dist < 0.4) {
                    state = 'INSPECTING';
                    updateUI('INSPECTING');
                }
            }
        }
        else if (state === 'INSPECTING') {
            // å¡ç‰Œè·Ÿéšæ‰‹åŠ¿
            // æ˜ å°„ pointer (-1~1) åˆ°ä¸–ç•Œåæ ‡
            const x = pointer.x * 10;
            const y = pointer.y * 7;
            targetPos.set(x, y, 5); // æ‹‰è¿‘åˆ° Z=5
            
            // æ—‹è½¬è·Ÿéšï¼šæ ¹æ®æ‰‹çš„ä½ç½®å€¾æ–œ
            // å¦‚æœæ˜¯é€†ä½ï¼ŒåŸºç¡€æ—‹è½¬æ˜¯ Z=180
            const baseRotZ = isReversed ? Math.PI : 0;
            const tiltX = -y * 0.1;
            const tiltY = x * 0.1;
            
            // å¹³æ»‘æ’å€¼
            cardMesh.position.lerp(targetPos, 0.1);
            
            // ç¿»è½¬é€»è¾‘ï¼šInspectæ—¶è®©æ­£é¢æœå‘å±å¹•
            // è¿™é‡Œçš„ rotation é€»è¾‘ï¼šä»èƒŒé¢ç¿»è½¬åˆ°æ­£é¢
            // ç®€å•å¤„ç†ï¼šç›´æ¥è®¾ç½®æ—‹è½¬
            const targetEuler = new THREE.Euler(tiltX, tiltY + (isReversed ? 0 : 0), baseRotZ); 
            // æ‰‹åŠ¨Lerp Quaternion
            const q = new THREE.Quaternion().setFromEuler(targetEuler);
            cardMesh.quaternion.slerp(q, 0.1);

            // ç¡®è®¤é€»è¾‘
            if (inputAction.isFist) {
                triggerAshEffect();
            }
            // é‡Šæ”¾é€»è¾‘
            if (!inputAction.isPinching && inputMode === 'HAND') {
                // æ‰‹åŠ¿æ¨¡å¼ä¸‹æ¾å¼€ä¼šæ‰è½/å›é€€ï¼Œè¿™é‡Œç®€åŒ–ä¸ºå›é€€åˆ° DRAWN
                state = 'DRAWN';
                updateUI('DRAWN');
            }
        }
        else if (state === 'WAITING') {
            // æ˜¾ç¤ºç©ºé—²/å¼•å¯¼
        }
        
        // æŒç»­æ›´æ–°ç²’å­
        if (state === 'DISINTEGRATING') {
            updateAsh();
        } else {
            // å¦‚æœä¸æ˜¯ç²’å­æ€ï¼Œæ™®é€šæ¸²æŸ“
            // å·²ç»ç”±ä¸Šé¢çš„é€»è¾‘å¤„ç† transform
        }

        renderer.render(scene, camera);
    }

    // --- 6. è¾“å…¥å¤„ç† (Hand & Mouse) ---
    
    // åˆå§‹åŒ– MediaPipe
    const videoElement = document.getElementById('input-video');
    let hands;

    function initHands() {
        hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onHandResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480, facingMode: "user"
        });
        
        return cameraUtils.start();
    }

    function onHandResults(results) {
        if (inputMode !== 'HAND') return;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            inputAction.active = true;
            const lm = results.multiHandLandmarks[0];
            
            // 1. è®¡ç®—æŒ‡é’ˆä½ç½® (é£ŸæŒ‡æ ¹éƒ¨)
            const indexBase = lm[5];
            // åæ ‡è½¬æ¢: MP (0~1) -> Three (-1~1)
            // æ³¨æ„ X è½´ç¿»è½¬
            pointer.x = (1 - indexBase.x) * 2 - 1; 
            pointer.y = (1 - indexBase.y) * 2 - 1;
            pointer.y *= -1; // Yè½´åè½¬

            // 2. æåˆæ£€æµ‹ (é£ŸæŒ‡æŒ‡å°– 8 - æ‹‡æŒ‡æŒ‡å°– 4)
            const t = lm[4]; const i = lm[8];
            const pinchDist = Math.hypot(t.x - i.x, t.y - i.y);
            inputAction.isPinching = pinchDist < 0.08;

            // 3. æ¡æ‹³æ£€æµ‹ (æŒ‡å°–åˆ°æŒå¿ƒ)
            // ç®€å•ç®—æ³•ï¼šä¸­æŒ‡æŒ‡å°–12 åˆ° æŒå¿ƒ0 çš„è·ç¦»ï¼Œç¼©çŸ­å³ä¸ºæ¡æ‹³
            const wrist = lm[0]; const mid = lm[12];
            const fistDist = Math.hypot(wrist.x - mid.x, wrist.y - mid.y);
            inputAction.isFist = fistDist < 0.25; // é˜ˆå€¼éœ€è°ƒè¯•

            // 4. æŒ‡ç¤º
            inputAction.isPointing = !inputAction.isFist && !inputAction.isPinching;
            
            updateStatusText();
        } else {
            inputAction.active = false;
        }
    }

    // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶ç›‘å¬
    window.addEventListener('mousemove', (e) => {
        if (inputMode !== 'MOUSE') return;
        pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    window.addEventListener('mousedown', () => { if(inputMode==='MOUSE') inputAction.isPinching = true; });
    window.addEventListener('mouseup', () => { if(inputMode==='MOUSE') inputAction.isPinching = false; });
    window.addEventListener('dblclick', () => { 
        if(inputMode==='MOUSE' && state === 'INSPECTING') triggerAshEffect(); 
    });

    // è§¦æ‘¸å±å…¼å®¹
    window.addEventListener('touchstart', (e) => {
        if(inputMode==='MOUSE') {
            pointer.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            inputAction.isPinching = true;
        }
    });
    window.addEventListener('touchend', () => { if(inputMode==='MOUSE') inputAction.isPinching = false; });


    // --- 7. UI ä¸ æµç¨‹æ§åˆ¶ ---

    function initApp() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'flex';
        
        initScene();
        createCardMesh();
        
        // å°è¯•å¯åŠ¨æ‘„åƒå¤´
        initHands().then(() => {
            console.log("Camera started");
            spawnNewCard();
            animate();
        }).catch(err => {
            console.warn("Camera failed, switching to Mouse mode", err);
            toggleInputMode(); // è‡ªåŠ¨é™çº§
            spawnNewCard();
            animate();
        });
    }

    function toggleInputMode() {
        if (inputMode === 'HAND') {
            inputMode = 'MOUSE';
            document.getElementById('mode-btn').innerText = 'ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼';
            document.getElementById('gesture-hints').style.display = 'none';
            document.getElementById('mouse-hints').style.display = 'flex';
            // åœæ­¢æ‘„åƒå¤´æµèŠ‚çœèµ„æº (å¯é€‰ï¼Œè¿™é‡Œç®€å•å¤„ç†ä¸åœæ­¢)
        } else {
            inputMode = 'HAND';
            document.getElementById('mode-btn').innerText = 'ğŸ– æ‰‹åŠ¿æ¨¡å¼';
            document.getElementById('gesture-hints').style.display = 'flex';
            document.getElementById('mouse-hints').style.display = 'none';
        }
    }

    function updateStatusText() {
        const el = document.getElementById('status-text');
        if (state === 'DRAWN') el.innerText = "ç‰Œçµå·²ç°ï¼Œè¯·æŠ“å– (PINCH)";
        else if (state === 'INSPECTING') el.innerText = "å‡è§†æ·±æ¸Š... æ¡æ‹³ (FIST) ç¡®è®¤";
        else if (state === 'DISINTEGRATING') el.innerText = "èƒ½é‡å½’è¿˜è™šç©º...";
    }

    function updateUI(curState) {
        updateStatusText();
        const meaningEl = document.getElementById('meaning-display');
        
        if (curState === 'INSPECTING') {
            // æ˜¾ç¤ºå«ä¹‰
            meaningEl.style.opacity = 1;
            const title = currentCardData.name + (isReversed ? " (é€†ä½)" : "");
            const desc = isReversed ? currentCardData.rev : currentCardData.up;
            
            document.getElementById('card-title').innerText = title;
            document.getElementById('card-title').style.color = isReversed ? '#ff6b6b' : '#ffd700';
            document.getElementById('card-desc').innerText = desc;
        } else {
            meaningEl.style.opacity = 0;
        }
    }

    function addToHistory() {
        const list = document.getElementById('history-list');
        const item = document.createElement('div');
        item.className = 'history-item';
        const status = isReversed ? "ğŸ”ƒ Reversed" : "â¬†ï¸ Upright";
        item.innerHTML = `<strong>${currentCardData.name}</strong><br><span style="color:${isReversed?'#ff6b6b':'#a892ff'}">${status}</span>`;
        list.insertBefore(item, list.firstChild);
    }

    // çª—å£è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
