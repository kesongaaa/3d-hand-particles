<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ‰‹åŠ¿ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* éšè—è§†é¢‘æºï¼Œåªç”¨äºè®¡ç®— */
        #input-video { display: none; }

        /* UI é¢æ¿å®¹å™¨ */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 10;
        }

        .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }

        /* æŒ‰é’®æ ·å¼ */
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: 0.3s;
            font-size: 14px;
        }
        button.active { background: #6c5ce7; font-weight: bold; }
        button:active { transform: scale(0.95); }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            background: none;
        }

        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            pointer-events: none;
            z-index: 20;
        }
        
        /* è°ƒè¯•ä¿¡æ¯ */
        #status {
            position: absolute;
            top: 10px; left: 10px;
            color: lime;
            font-size: 12px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 5px;
        }
    </style>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´ä¸AIæ¨¡å‹...<br><span style="font-size:14px; opacity:0.7">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    <div id="status">ç­‰å¾…æ‰‹åŠ¿...</div>

    <!-- éšè—çš„è§†é¢‘å…ƒç´ ç”¨äºæ•æ‰ -->
    <video id="input-video" playsinline></video>

    <!-- UI é¢æ¿ -->
    <div id="ui-container">
        <div class="row">
            <button onclick="setShape('heart')" class="active" id="btn-heart">â¤ï¸ çˆ±å¿ƒ</button>
            <button onclick="setShape('flower')" id="btn-flower">ğŸŒ¸ èŠ±æœµ</button>
            <button onclick="setShape('saturn')" id="btn-saturn">ğŸª åœŸæ˜Ÿ</button>
            <button onclick="setShape('firework')" id="btn-firework">ğŸ† çƒŸèŠ±</button>
        </div>
        <div class="row">
            <span>ç²’å­é¢œè‰²:</span>
            <input type="color" id="colorPicker" value="#ff0055">
            <button onclick="toggleFullScreen()">â›¶ å…¨å±</button>
        </div>
    </div>

<script>
    // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    // æ·»åŠ ä¸€ç‚¹é›¾æ•ˆå¢åŠ æ·±é‚ƒæ„Ÿ
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ä¼˜åŒ–ç§»åŠ¨ç«¯æ€§èƒ½
    document.body.appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
    const particleCount = 2000; // ç§»åŠ¨ç«¯å»ºè®®ä¿æŒåœ¨ 2000-4000 å·¦å³
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    // å­˜å‚¨æ¯ä¸ªç²’å­çš„ç›®æ ‡ä½ç½®ï¼ˆç”¨äºå½¢çŠ¶å˜æ¢ï¼‰
    const targetPositions = new Float32Array(particleCount * 3);
    
    // åˆå§‹åŒ–ä½ç½®ä¸ºéšæœº
    for(let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // æè´¨
    const material = new THREE.PointsMaterial({
        color: 0xff0055,
        size: 0.3,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. å½¢çŠ¶ç”Ÿæˆé€»è¾‘ (æ•°å­¦å…¬å¼) ---
    function getShapeFunction(type) {
        return (i) => {
            const idx = i * 3;
            let x, y, z;
            
            // å½’ä¸€åŒ–ç´¢å¼• 0 to 1
            const t = i / particleCount;
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;

            if (type === 'heart') {
                // 3D çˆ±å¿ƒå…¬å¼
                const r = 10; // åŠå¾„
                // ä½¿ç”¨çƒåæ ‡ç³»éšæœºåˆ†å¸ƒï¼Œç„¶åæ˜ å°„åˆ°çˆ±å¿ƒå½¢çŠ¶
                // è¿™é‡Œç”¨æ›´ç®€å•çš„ parametric å˜ä½“
                const beta = Math.random() * Math.PI * 2;
                const alpha = Math.random() * Math.PI;
                // è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„å¿ƒå½¢æ›²é¢è¿‘ä¼¼
                x = 16 * Math.pow(Math.sin(beta), 3) * Math.sin(alpha);
                y = (13 * Math.cos(beta) - 5 * Math.cos(2*beta) - 2 * Math.cos(3*beta) - Math.cos(4*beta)) * Math.sin(alpha);
                z = 4 * Math.cos(alpha) * 5; // æ‹‰ä¼¸Zè½´
                // ç¼©æ”¾
                x *= 0.05; y *= 0.05; z *= 0.05;
            } else if (type === 'saturn') {
                // 70% ç²’å­åšçƒä½“ï¼Œ30% åšå…‰ç¯
                if (Math.random() > 0.3) {
                    const r = 4;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 6 + Math.random() * 3; // å…‰ç¯åŠå¾„
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = (Math.random() - 0.5) * 0.5; // å…‰ç¯åšåº¦
                }
            } else if (type === 'flower') {
                // æåæ ‡èŠ±æœµ
                const r = 5 + 2 * Math.sin(5 * theta);
                x = r * Math.cos(theta) * Math.sin(phi);
                y = r * Math.sin(theta) * Math.sin(phi);
                z = r * Math.cos(phi) * 0.5; // å‹æ‰ä¸€ç‚¹
            } else { // firework / sphere
                const r = 8 * Math.cbrt(Math.random()); // å‡åŒ€çƒä½“åˆ†å¸ƒ
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }

            return {x, y, z};
        };
    }

    function updateTargets(shapeName) {
        const shapeFunc = getShapeFunction(shapeName);
        for(let i = 0; i < particleCount; i++) {
            const pos = shapeFunc(i);
            targetPositions[i * 3] = pos.x;
            targetPositions[i * 3 + 1] = pos.y;
            targetPositions[i * 3 + 2] = pos.z;
        }
    }

    // åˆå§‹å½¢çŠ¶
    updateTargets('heart');

    // --- 4. äº¤äº’ä¸åŠ¨ç”»é€»è¾‘ ---
    let handOpenFactor = 1.0; // 1.0 = å¼ å¼€ (é»˜è®¤), 0.0 = é—­åˆ
    let currentScale = 1.0;
    
    // UI æ§åˆ¶
    function setShape(name) {
        updateTargets(name);
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + name).classList.add('active');
    }

    document.getElementById('colorPicker').addEventListener('input', (e) => {
        material.color.set(e.target.value);
    });

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => console.log(err));
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    // åŠ¨ç”»å¾ªç¯
    function animate() {
        requestAnimationFrame(animate);

        const positionsArray = geometry.attributes.position.array;
        
        // å“åº”æ‰‹åŠ¿ï¼šæ ¹æ® handOpenFactor è°ƒæ•´ç¼©æ”¾
        // ç›®æ ‡ç¼©æ”¾ï¼šæ‰‹å¼ å¼€(1) -> 1.5å€å¤§å°, æ‰‹é—­åˆ(0) -> 0.3å€å¤§å°
        const targetScale = 0.3 + (handOpenFactor * 1.5);
        // å¹³æ»‘æ’å€¼ (Lerp)
        currentScale += (targetScale - currentScale) * 0.1;

        // æ—‹è½¬æ•´ä¸ªç²’å­ç³»ç»Ÿ
        particles.rotation.y += 0.002;
        particles.rotation.z += 0.001;

        // æ›´æ–°æ¯ä¸ªç²’å­ä½ç½®
        for(let i = 0; i < particleCount; i++) {
            const idx = i * 3;
            
            // åŸºç¡€ç›®æ ‡ä½ç½®
            const tx = targetPositions[idx];
            const ty = targetPositions[idx + 1];
            const tz = targetPositions[idx + 2];

            // 1. å½¢çŠ¶å˜å½¢æ’å€¼ï¼šè®©å½“å‰ä½ç½®æ…¢æ…¢é£å‘ç›®æ ‡ä½ç½®
            positionsArray[idx] += (tx * currentScale - positionsArray[idx]) * 0.05;
            positionsArray[idx+1] += (ty * currentScale - positionsArray[idx+1]) * 0.05;
            positionsArray[idx+2] += (tz * currentScale - positionsArray[idx+2]) * 0.05;
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();

    // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ«é›†æˆ ---
    const videoElement = document.getElementById('input-video');
    const statusDiv = document.getElementById('status');
    const loadingDiv = document.getElementById('loading');

    function onResults(results) {
        loadingDiv.style.display = 'none'; // éšè—åŠ è½½ä¸­
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusDiv.innerText = "æ£€æµ‹åˆ°æ‰‹åŠ¿";
            statusDiv.style.color = "lime";
            
            const landmarks = results.multiHandLandmarks[0];
            
            // è·å–æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            // è®¡ç®—è·ç¦» (ç®€å•çš„æ¬§å‡ é‡Œå¾—è·ç¦»ï¼Œå¿½ç•¥Zè½´ä»¥ç®€åŒ–è®¡ç®—)
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // è·ç¦»æ˜ å°„: 
            // è·ç¦»é€šå¸¸åœ¨ 0.02 (æåˆ) åˆ° 0.2 (å¼ å¼€) ä¹‹é—´ï¼Œè§†æ‘„åƒå¤´è·ç¦»è€Œå®š
            // æˆ‘ä»¬è®¾ç½®é˜ˆå€¼
            let val = (distance - 0.03) / (0.15 - 0.03);
            val = Math.max(0, Math.min(1, val)); // Clamp 0-1
            
            // å¹³æ»‘èµ‹å€¼
            handOpenFactor += (val - handOpenFactor) * 0.2;
            
        } else {
            statusDiv.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
            statusDiv.style.color = "red";
            // å¦‚æœæ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œé»˜è®¤æ…¢æ…¢æ¢å¤å¼ å¼€çŠ¶æ€
            handOpenFactor += (1.0 - handOpenFactor) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1, // ç§»åŠ¨ç«¯è®¾ä¸º0æˆ–1ä»¥æé«˜æ€§èƒ½
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480,
        facingMode: "user" // ä½¿ç”¨å‰ç½®æ‘„åƒå¤´
    });
    
    cameraUtils.start()
        .then(() => console.log("Camera started"))
        .catch(err => {
            console.error(err);
            loadingDiv.innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´<br>è¯·ç¡®ä¿åœ¨HTTPSç¯å¢ƒä¸‹è¿è¡Œ<br>æˆ–åœ¨Safariä¸­å…è®¸æƒé™";
        });

    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
