<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>é­”æ³•å¸ˆï¼šå¡ç‰Œæ“æ§ (iOSä¿®å¤ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Courier New', sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* å…³é”®ï¼šiOS å¿…é¡»è®© video å…ƒç´ å®é™…å­˜åœ¨äº DOM ä¸­ä¸” playsinline */
        #input-video { 
            position: absolute; 
            top: 0; left: 0; 
            width: 1px; height: 1px; 
            opacity: 0; 
            pointer-events: none;
            z-index: 0; 
        }

        /* å¯åŠ¨é®ç½©å±‚ */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #00f3ff;
            text-align: center;
        }

        button#start-btn {
            background: transparent;
            border: 2px solid #00f3ff;
            color: #00f3ff;
            padding: 15px 40px;
            font-size: 20px;
            margin-top: 20px;
            cursor: pointer;
            box-shadow: 0 0 15px #00f3ff;
            border-radius: 5px;
            font-family: 'Courier New', sans-serif;
            font-weight: bold;
        }

        /* é”™è¯¯æ—¥å¿—æ˜¾ç¤ºåŒº */
        #debug-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 90%;
            max-height: 100px;
            overflow-y: auto;
            color: red;
            font-size: 10px;
            z-index: 1000;
            background: rgba(0,0,0,0.5);
            pointer-events: none;
            display: none; /* é»˜è®¤éšè—ï¼Œå‡ºé”™æ˜¾ç¤º */
        }

        #hud {
            position: absolute;
            top: 20px; left: 20px;
            color: #00f3ff;
            text-shadow: 0 0 5px #00f3ff;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 12px; opacity: 0.8; }
        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.6); font-size: 12px; pointer-events: none; z-index: 10;
        }
        .highlight { color: #ff0055; font-weight: bold; }
        .highlight-blue { color: #00f3ff; font-weight: bold; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- è°ƒè¯•æ—¥å¿— -->
    <div id="debug-log"></div>

    <!-- å¯åŠ¨å±å¹• -->
    <div id="start-screen">
        <h1>ARCANE ENGINE</h1>
        <p>éœ€è¦æ‘„åƒå¤´æƒé™ä»¥æ–½å±•é­”æ³•</p>
        <button id="start-btn" onclick="startMagic()">ğŸ”® å¼€å¯é­”æ³•</button>
        <p style="font-size: 10px; margin-top:20px; color: #666;">ç‚¹å‡»å…è®¸æ‘„åƒå¤´è®¿é—®</p>
    </div>

    <div id="hud" style="display:none;">
        <h1>Arcane Deck</h1>
        <p id="state-text">SYSTEM: INITIALIZING...</p>
    </div>

    <div id="instructions" style="display:none;">
        ğŸ‘Œ <span class="highlight-blue">æåˆ</span> æŠ“å– &nbsp;|&nbsp; 
        ğŸ‘‹ <span class="highlight-blue">æŒ¥åŠ¨</span> æŠ•æ· &nbsp;|&nbsp; 
        âœŠ <span class="highlight">æ¡æ‹³</span> æ‘§æ¯
    </div>

    <!-- å¿…é¡»æ·»åŠ  playsinline å±æ€§ -->
    <video id="input-video" playsinline muted autoplay></video>

<script>
    // --- é”™è¯¯æ•æ‰è¾…åŠ©å‡½æ•° ---
    function logError(msg) {
        const log = document.getElementById('debug-log');
        log.style.display = 'block';
        log.innerHTML += `> ${msg}<br>`;
        console.error(msg);
    }
    
    window.onerror = function(message, source, lineno, colno, error) {
        logError(`System Error: ${message}`);
    };

    // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.03);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0x00f3ff, 2, 50);
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // --- 2. é­”æ³•å¡ç‰Œè´´å›¾ ---
    function createCardTexture(color, type) {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 800;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, 512, 800);
        grd.addColorStop(0, '#1a1a2e'); grd.addColorStop(1, '#16213e');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 512, 800);
        ctx.lineWidth = 20; ctx.strokeStyle = color; ctx.strokeRect(20, 20, 472, 760);
        ctx.shadowBlur = 20; ctx.shadowColor = color;
        ctx.beginPath(); ctx.arc(256, 400, 100, 0, Math.PI * 2); ctx.lineWidth = 10; ctx.stroke();
        ctx.fillStyle = color; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center';
        ctx.fillText(type === 'front' ? "THE VOID" : "ARCANE", 256, 420);
        return new THREE.CanvasTexture(canvas);
    }

    const cardGroup = new THREE.Group();
    const cardMesh = new THREE.Mesh(
        new THREE.BoxGeometry(4, 6, 0.1),
        [
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ map: createCardTexture('#00f3ff', 'front'), emissive: 0x00f3ff, emissiveIntensity: 0.2 }),
            new THREE.MeshStandardMaterial({ map: createCardTexture('#ff0055', 'back'), emissive: 0xff0055, emissiveIntensity: 0.2 })
        ]
    );
    cardGroup.add(cardMesh);
    scene.add(cardGroup);

    // --- 3. ç²’å­ç³»ç»Ÿ ---
    const particleCount = 1000;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(particleCount * 3);
    const pVel = new Float32Array(particleCount * 3);
    const pLife = new Float32Array(particleCount);
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({ color: 0x00f3ff, size: 0.2, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
    const explosionSystem = new THREE.Points(pGeo, pMat);
    scene.add(explosionSystem);

    const trailGeo = new THREE.BufferGeometry();
    const trailPos = new Float32Array(60); // 20 points * 3
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
    const trailMesh = new THREE.Points(trailGeo, new THREE.PointsMaterial({ color: 0xffaa00, size: 0.3, transparent: true, opacity: 0.6 }));
    scene.add(trailMesh);

    // --- å˜é‡ ---
    let cardState = 'IDLE';
    let handPos = new THREE.Vector3();
    let handRot = new THREE.Quaternion();
    let pinchDistance = 1;
    let isFist = false;
    let velocity = new THREE.Vector3();
    let lastHandPos = new THREE.Vector3();
    let respawnTimer = 0;

    // --- åŠ¨ç”»å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);

        // å¡ç‰Œé€»è¾‘
        if (cardState === 'GRABBED') {
            cardGroup.position.lerp(handPos, 0.2);
            cardGroup.quaternion.slerp(handRot, 0.2);
            velocity.copy(handPos).sub(lastHandPos).multiplyScalar(1.5);
            if (isFist) triggerDestruction();
            else if (pinchDistance > 0.1) cardState = 'THROWN';
        } else if (cardState === 'THROWN') {
            cardGroup.position.add(velocity);
            cardGroup.rotation.x += velocity.y * 0.2;
            cardGroup.rotation.z -= velocity.x * 0.2;
            velocity.multiplyScalar(0.95);
            if (Math.abs(cardGroup.position.x) > 15 || Math.abs(cardGroup.position.y) > 10) triggerRespawn();
            if (velocity.length() < 0.01) cardState = 'IDLE';
            if (pinchDistance < 0.06 && handPos.distanceTo(cardGroup.position) < 3) cardState = 'GRABBED';
        } else if (cardState === 'IDLE') {
            const time = Date.now() * 0.001;
            cardGroup.position.y += Math.sin(time) * 0.005;
            cardGroup.position.lerp(new THREE.Vector3(0, 0, 0), 0.02);
            if (pinchDistance < 0.06 && handPos.distanceTo(cardGroup.position) < 4) cardState = 'GRABBED';
            if (isFist && handPos.distanceTo(cardGroup.position) < 4) triggerDestruction();
        } else if (cardState === 'DESTROYED') {
            updateExplosion();
            respawnTimer++;
            if (respawnTimer > 100) triggerRespawn();
        }

        updateTrail();
        lastHandPos.copy(handPos);
        renderer.render(scene, camera);
        
        if(document.getElementById('state-text')) {
             document.getElementById('state-text').innerText = `STATUS: ${cardState}`;
        }
    }

    function triggerDestruction() {
        if(cardState === 'DESTROYED') return;
        cardState = 'DESTROYED';
        cardGroup.visible = false;
        const center = cardGroup.position;
        const positions = pGeo.attributes.position.array;
        for(let i=0; i<particleCount; i++) {
            const idx = i*3;
            pPos[idx] = center.x + (Math.random()-0.5)*2;
            pPos[idx+1] = center.y + (Math.random()-0.5)*3;
            pPos[idx+2] = center.z + (Math.random()-0.5)*0.5;
            pVel[idx] = (Math.random()-0.5)*0.5; pVel[idx+1] = (Math.random()-0.5)*0.5; pVel[idx+2] = (Math.random()-0.5)*0.5;
            pLife[i] = 1.0;
        }
        pMat.opacity = 1;
        pGeo.attributes.position.needsUpdate = true;
        respawnTimer = 0;
    }

    function updateExplosion() {
        const positions = pGeo.attributes.position.array;
        for(let i=0; i<particleCount; i++) {
            if(pLife[i] > 0) {
                const idx = i*3;
                positions[idx] += pVel[idx]; positions[idx+1] += pVel[idx+1]; positions[idx+2] += pVel[idx+2];
                pVel[idx+1] -= 0.005; pVel[idx] *= 0.98; pVel[idx+1] *= 0.98; pVel[idx+2] *= 0.98;
                pLife[i] -= 0.01;
            }
        }
        pMat.opacity -= 0.01;
        pGeo.attributes.position.needsUpdate = true;
    }

    function triggerRespawn() {
        cardState = 'IDLE'; cardGroup.visible = true;
        cardGroup.position.set(0, 0, -5); cardGroup.scale.set(0,0,0);
        let s = 0; const t = setInterval(() => { s+=0.1; cardGroup.scale.set(s,s,s); if(s>=1) clearInterval(t); }, 16);
    }

    function updateTrail() {
        const arr = trailGeo.attributes.position.array;
        for(let i = 59; i >= 3; i--) arr[i] = arr[i-3];
        arr[0] = handPos.x; arr[1] = handPos.y; arr[2] = handPos.z;
        trailGeo.attributes.position.needsUpdate = true;
    }

    // --- å¯åŠ¨é€»è¾‘ ---
    let cameraStarted = false;

    async function startMagic() {
        const btn = document.getElementById('start-btn');
        btn.innerText = "æ­£åœ¨åˆå§‹åŒ–...";
        btn.disabled = true;

        try {
            // æ˜¾å¼è¯·æ±‚æ‘„åƒå¤´æƒé™
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            });

            // æˆåŠŸè·å–æµ
            const videoElement = document.getElementById('input-video');
            videoElement.srcObject = stream;
            
            // ç¡®ä¿è§†é¢‘æ’­æ”¾ï¼ˆiOS éœ€è¦ï¼‰
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                initHands(); // åˆå§‹åŒ–AI
                
                // éšè—å¯åŠ¨å±
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('instructions').style.display = 'block';
                animate();
            };

        } catch (err) {
            logError("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.name + " - " + err.message);
            btn.innerText = "å¯åŠ¨å¤±è´¥ (æŸ¥çœ‹ä¸‹æ–¹æ—¥å¿—)";
            btn.style.borderColor = "red";
            btn.style.color = "red";
        }
    }

    function initHands() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // é™çº§ä»¥æé«˜é€Ÿåº¦
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0]; const index = lm[5];
                
                // åæ ‡æ˜ å°„
                const x = (0.5 - index.x) * 20;
                const y = (0.5 - index.y) * 15;
                handPos.lerp(new THREE.Vector3(x, y, 0), 0.5);

                // æåˆè®¡ç®—
                const t = lm[4]; const i = lm[8];
                pinchDistance = Math.sqrt(Math.pow(t.x-i.x,2) + Math.pow(t.y-i.y,2));

                // æ¡æ‹³è®¡ç®—
                const m = lm[12];
                isFist = Math.sqrt(Math.pow(m.x-wrist.x,2) + Math.pow(m.y-wrist.y,2)) < 0.15;
                
                // ç®€å•æ—‹è½¬
                handRot.setFromEuler(new THREE.Euler((index.y-wrist.y)*-3, (index.x-wrist.x)*3, (index.x-wrist.x)*-2));
            }
        });

        // æŒç»­å‘é€è§†é¢‘å¸§ç»™ AI
        const videoElement = document.getElementById('input-video');
        async function sendFrame() {
            if(!videoElement.paused && !videoElement.ended) {
                await hands.send({image: videoElement});
            }
            requestAnimationFrame(sendFrame);
        }
        sendFrame();
    }

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
