<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 纯净粒子流体</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000205; font-family: sans-serif; }
        
        /* 隐藏视频，只保留逻辑 */
        #video-container {
            position: absolute; bottom: 10px; left: 10px;
            width: 120px; height: 90px;
            opacity: 0.3; /* 半透明，不干扰视觉 */
            border-radius: 8px; overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* 复刻截图中的加载样式 */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000205; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.8s ease;
        }
        
        /* 蓝色圆环加载动画 */
        .spinner {
            width: 50px; height: 50px;
            border: 4px solid rgba(0, 200, 255, 0.2);
            border-top: 4px solid #00d2ff; /* 亮蓝 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #00d2ff;
            font-size: 16px;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- 核心库 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">正在初始化视觉核心...</div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 核心配置 ---
        const CONFIG = {
            count: 35000,         // 粒子数量增加到3.5万，更细腻
            radius: 12,           // 默认球体半径
            colorInner: new THREE.Color(0x0066ff), // 核心蓝
            colorOuter: new THREE.Color(0x00ffff), // 外部青
        };

        let scene, camera, renderer, particles, material;
        let time = 0;
        
        // 交互状态
        let state = {
            expansion: 1.0,       // 粒子扩散度
            turbulence: 0.2,      // 扰动程度
            rotationVel: 0.0,     // 额外的旋转速度 (手势控制)
            baseSpeed: 0.002      // 基础自转速度
        };
        let targetState = { expansion: 1.0, turbulence: 0.2, rotationVel: 0.0 };

        // --- 1. 场景初始化 ---
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000205); // 极深蓝黑背景
            scene.fog = new THREE.FogExp2(0x000205, 0.02); // 雾气融合

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 45;

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createParticles();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 2. 创建细腻粒子系统 (Shader) ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const randomness = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < CONFIG.count; i++) {
                // 球体分布算法 (更均匀)
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                
                // 增加一些随机深度，不只是一个空心壳，而是一个有厚度的云团
                const r = CONFIG.radius * (0.8 + Math.random() * 0.4); 

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions.push(x, y, z);

                // 随机属性用于动画
                randomness.push(Math.random(), Math.random(), Math.random());

                // 颜色渐变：根据深度混合
                const mixRatio = Math.random();
                const c = new THREE.Color().lerpColors(CONFIG.colorInner, CONFIG.colorOuter, mixRatio);
                colors.push(c.r, c.g, c.b);

                // 粒子大小随机 (模拟尘埃大小不一)
                sizes.push(Math.random() * 1.5 + 0.5);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('randomness', new THREE.Float32BufferAttribute(randomness, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // 自定义 Shader (解决粗糙感的关键)
            // 我们直接在 Shader 里画圆，而不是用贴图，这样无限放大边缘也是圆滑的
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uExpansion: { value: 1.0 },
                    uTurbulence: { value: 0.0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uExpansion;
                    uniform float uTurbulence;
                    
                    attribute vec3 randomness;
                    attribute vec3 color;
                    attribute float size;
                    
                    varying vec3 vColor;
                    varying float vAlpha;

                    // 噪声函数
                    float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }

                    void main() {
                        vColor = color;
                        vec3 pos = position;

                        // 1. 基础呼吸
                        float breath = sin(uTime * 1.5 + randomness.x * 10.0) * 0.5;
                        
                        // 2. 爆炸/扩散逻辑
                        vec3 dir = normalize(pos); // 从中心向外的方向
                        
                        // 扰动位置
                        pos += dir * breath * uTurbulence; 
                        pos += dir * (uExpansion - 1.0) * 20.0 * randomness.y; // 炸开时随机飞散
                        
                        // 3. 整体缩放
                        pos *= uExpansion;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        // 4. 大小计算 (近大远小)
                        // 细腻的关键：这里不设太大的上限，防止出现大马赛克
                        gl_PointSize = size * (200.0 / -mvPosition.z);
                        
                        // 根据距离淡出
                        vAlpha = smoothstep(60.0, 40.0, length(mvPosition.xyz)); 
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // 【核心优化】程序化画圆
                        // 计算当前像素点距离中心的距离 (0.0 到 0.5)
                        float d = distance(gl_PointCoord, vec2(0.5));
                        
                        // 如果超出半径，直接丢弃 (变为圆形)
                        if(d > 0.5) discard;

                        // 制作柔和边缘 (Soft Glow)
                        // 使用 smoothstep 让中心实，边缘极度柔和
                        float glow = 1.0 - smoothstep(0.0, 0.5, d);
                        glow = pow(glow, 2.0); // 增强中心亮度，让边缘更淡

                        gl_FragColor = vec4(vColor, vAlpha * glow);
                    }
                `,
                blending: THREE.AdditiveBlending, // 叠加发光模式
                depthWrite: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 3. 手势与动画循环 ---
        
        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20].map(i => landmarks[i]); // 5指指尖
            
            // 计算指尖到手腕距离
            const dists = tips.map(p => Math.sqrt(Math.pow(p.x-wrist.x, 2) + Math.pow(p.y-wrist.y, 2)));
            const avgDist = dists.reduce((a,b)=>a+b) / 5;

            // 1. 握拳 (FIST) -> 收缩
            if (avgDist < 0.15) return 'FIST';

            // 2. 张手 (OPEN) -> 炸开
            if (avgDist > 0.35) return 'OPEN';

            // 3. 互动旋转 (ROTATE) -> 食指伸出
            // 判断逻辑：食指伸直，小指弯曲
            const indexOut = dists[1] > 0.25;
            const pinkyIn = dists[4] < 0.2;
            if (indexOut && pinkyIn) return 'ROTATE';

            return 'IDLE';
        }

        function updateState() {
            // 平滑插值 (Lerp) 让动画更跟手但有惯性
            const lerpSpeed = 0.08;
            state.expansion += (targetState.expansion - state.expansion) * lerpSpeed;
            state.turbulence += (targetState.turbulence - state.turbulence) * lerpSpeed;
            state.rotationVel += (targetState.rotationVel - state.rotationVel) * lerpSpeed;

            // 更新 Shader
            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uExpansion.value = state.expansion;
                material.uniforms.uTurbulence.value = state.turbulence;
            }

            // 应用旋转 (基础自转 + 手势控制)
            if (particles) {
                particles.rotation.y += state.baseSpeed + state.rotationVel;
                particles.rotation.x += state.rotationVel * 0.2; // 稍微带一点上下倾斜
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            updateState();
            renderer.render(scene, camera);
        }

        // --- 4. MediaPipe 初始化 ---
        function initMediaPipe() {
            if (!window.Hands) { setTimeout(initMediaPipe, 100); return; }

            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            
            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const gesture = detectGesture(lm);

                    if (gesture === 'OPEN') {
                        // 炸开
                        targetState.expansion = 3.0;
                        targetState.turbulence = 2.0;
                        targetState.rotationVel = 0;
                    } 
                    else if (gesture === 'FIST') {
                        // 收缩
                        targetState.expansion = 0.3;
                        targetState.turbulence = 0.0;
                        targetState.rotationVel = 0;
                    } 
                    else if (gesture === 'ROTATE') {
                        // 【新功能】手指滑动旋转
                        targetState.expansion = 1.0;
                        targetState.turbulence = 0.5;

                        // 获取食指尖的 X 坐标 (0.0 左 -> 1.0 右)
                        const indexTipX = lm[8].x;
                        
                        // 映射逻辑：
                        // 如果手指在屏幕左侧 (x < 0.4)，向左旋转
                        // 如果手指在屏幕右侧 (x > 0.6)，向右旋转
                        // 中间则是停止
                        if (indexTipX < 0.4) {
                            targetState.rotationVel = 0.05; // 向左转
                        } else if (indexTipX > 0.6) {
                            targetState.rotationVel = -0.05; // 向右转
                        } else {
                            targetState.rotationVel = 0.0;
                        }
                    } 
                    else {
                        // 待机
                        targetState.expansion = 1.0;
                        targetState.turbulence = 0.2;
                        targetState.rotationVel = 0;
                    }
                } else {
                    // 无手势
                    targetState.expansion = 1.0;
                    targetState.rotationVel = 0;
                }
            });

            const cam = new window.Camera(document.getElementById('input-video'), {
                onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
                width: 320, height: 240
            });
            
            cam.start().then(() => {
                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 800);
            });
        }

        initScene();
        animate();
        initMediaPipe();

    </script>
</body>
</html>
