<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>é­”æ³•å¸ˆï¼šå¡ç‰Œæ“æ§</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
        #input-video { display: none; }

        /* HUD ç•Œé¢ */
        #hud {
            position: absolute;
            top: 20px; left: 20px;
            color: #00f3ff;
            text-shadow: 0 0 5px #00f3ff;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 12px; opacity: 0.8; }

        /* æŠ€èƒ½æŒ‡ç¤ºå™¨ */
        #instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            pointer-events: none;
            line-height: 1.5;
        }
        .highlight { color: #ff0055; font-weight: bold; }
        .highlight-blue { color: #00f3ff; font-weight: bold; }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½é­”æ³•å¼•æ“...<br><small>è¯·å…è®¸æ‘„åƒå¤´æƒé™</small></div>

    <div id="hud">
        <h1>Arcane Deck</h1>
        <p id="state-text">SYSTEM: ONLINE</p>
        <p id="fps-text">FPS: 60</p>
    </div>

    <div id="instructions">
        ğŸ‘Œ <span class="highlight-blue">æåˆ</span> æŠ“å–å¡ç‰Œ &nbsp;|&nbsp; 
        ğŸ‘‹ <span class="highlight-blue">æŒ¥åŠ¨æ¾å¼€</span> æŠ•æ· &nbsp;|&nbsp; 
        âœŠ <span class="highlight">æ¡æ‹³</span> æ‘§æ¯
    </div>

    <video id="input-video" playsinline></video>

<script>
    // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.03);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // å¼€å¯å‘å…‰éœ€è¦çš„è‰²å½©ç©ºé—´
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0x00f3ff, 2, 50);
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // --- 2. åˆ¶ä½œé­”æ³•å¡ç‰Œ (ä½¿ç”¨ Canvas åŠ¨æ€ç”Ÿæˆè´´å›¾) ---
    function createCardTexture(color, type) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');

        // èƒŒæ™¯
        const grd = ctx.createLinearGradient(0, 0, 512, 800);
        grd.addColorStop(0, '#1a1a2e');
        grd.addColorStop(1, '#16213e');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 512, 800);

        // è¾¹æ¡†
        ctx.lineWidth = 20;
        ctx.strokeStyle = color;
        ctx.strokeRect(20, 20, 472, 760);

        // é­”æ³•ç¬¦æ–‡ (éšæœºåœ†åœˆ)
        ctx.strokeStyle = color;
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        
        ctx.beginPath();
        ctx.arc(256, 400, 100, 0, Math.PI * 2);
        ctx.lineWidth = 10;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(256, 400, 140, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.setLineDash([15, 10]);
        ctx.stroke();

        // æ–‡å­—
        ctx.fillStyle = color;
        ctx.font = 'bold 60px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(type === 'front' ? "THE VOID" : "ARCANE", 256, 420);
        
        // è£…é¥°çº¹ç†
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(256, 200);
        ctx.lineTo(256, 600);
        ctx.stroke();

        return new THREE.CanvasTexture(canvas);
    }

    const cardGeometry = new THREE.BoxGeometry(4, 6, 0.1);
    const cardMaterial = [
        new THREE.MeshStandardMaterial({ color: 0x111111 }), // Right
        new THREE.MeshStandardMaterial({ color: 0x111111 }), // Left
        new THREE.MeshStandardMaterial({ color: 0x111111 }), // Top
        new THREE.MeshStandardMaterial({ color: 0x111111 }), // Bottom
        new THREE.MeshStandardMaterial({ map: createCardTexture('#00f3ff', 'front'), emissive: 0x00f3ff, emissiveIntensity: 0.2 }), // Front
        new THREE.MeshStandardMaterial({ map: createCardTexture('#ff0055', 'back'), emissive: 0ff0055, emissiveIntensity: 0.2 })  // Back
    ];

    const cardGroup = new THREE.Group();
    const cardMesh = new THREE.Mesh(cardGeometry, cardMaterial);
    cardGroup.add(cardMesh);
    scene.add(cardGroup);

    // --- 3. çˆ†ç‚¸ç²’å­ç³»ç»Ÿ ---
    const particleCount = 1500;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(particleCount * 3);
    const pVel = new Float32Array(particleCount * 3);
    const pLife = new Float32Array(particleCount); // ç”Ÿå‘½å‘¨æœŸ

    for(let i=0; i<particleCount*3; i++) {
        pPos[i] = 0;
        pVel[i] = 0;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));

    const pMat = new THREE.PointsMaterial({
        color: 0x00f3ff,
        size: 0.2,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending
    });
    const explosionSystem = new THREE.Points(pGeo, pMat);
    scene.add(explosionSystem);

    // --- 4. é­”æ³•æ‹–å°¾ (Trail) ---
    const trailSize = 20;
    const trailGeo = new THREE.BufferGeometry();
    const trailPos = new Float32Array(trailSize * 3);
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
    const trailMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.3, transparent: true, opacity: 0.6 });
    const trailMesh = new THREE.Points(trailGeo, trailMat);
    scene.add(trailMesh);

    // --- çŠ¶æ€å˜é‡ ---
    let cardState = 'IDLE'; // IDLE, HOVER, GRABBED, THROWN, DESTROYED, RESPAWNING
    let handPos = new THREE.Vector3(0, 0, 0);
    let handRot = new THREE.Quaternion();
    let pinchDistance = 1;
    let isFist = false;
    
    // ç‰©ç†æ¨¡æ‹Ÿå˜é‡
    let velocity = new THREE.Vector3(0, 0, 0);
    let angularVelocity = new THREE.Vector3(0, 0, 0);
    let lastHandPos = new THREE.Vector3();
    let respawnTimer = 0;

    // --- äº¤äº’é€»è¾‘ ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. å¡ç‰Œé€»è¾‘
        if (cardState === 'GRABBED') {
            // å¡ç‰Œç´§è·Ÿæ‰‹çš„ä½ç½®ï¼Œä½¿ç”¨æ’å€¼æ›´å¹³æ»‘
            cardGroup.position.lerp(handPos, 0.2);
            cardGroup.quaternion.slerp(handRot, 0.2);
            
            // è®¡ç®—æŠ•æ·é€Ÿåº¦
            const deltaMove = new THREE.Vector3().subVectors(handPos, lastHandPos);
            velocity.copy(deltaMove).multiplyScalar(1.5); // å¢åŠ ä¸€ç‚¹åŠ›åº¦
            
            // å¦‚æœå˜æˆæ‹³å¤´ï¼Œæ‘§æ¯
            if (isFist) triggerDestruction();
            // å¦‚æœæ¾å¼€æåˆï¼ŒæŠ•æ·
            else if (pinchDistance > 0.1) cardState = 'THROWN';

        } else if (cardState === 'THROWN') {
            // ç‰©ç†è¿åŠ¨
            cardGroup.position.add(velocity);
            cardGroup.rotation.x += velocity.y * 0.2;
            cardGroup.rotation.z -= velocity.x * 0.2;
            
            // é˜»åŠ›
            velocity.multiplyScalar(0.95);
            
            // è¾¹ç•Œåå¼¹æˆ–é‡ç½®
            if (Math.abs(cardGroup.position.x) > 15 || Math.abs(cardGroup.position.y) > 10) {
                // é£å‡ºå±å¹•å¤ªè¿œï¼Œè‡ªåŠ¨é‡ç½®
                triggerRespawn();
            }
            // å¦‚æœé€Ÿåº¦å¾ˆæ…¢ï¼Œå˜å›æ‚¬æµ®
            if (velocity.length() < 0.01) cardState = 'IDLE';
            
            // å…è®¸ç©ºä¸­æŠ“å–
            if (pinchDistance < 0.06 && handPos.distanceTo(cardGroup.position) < 3) {
                cardState = 'GRABBED';
            }

        } else if (cardState === 'IDLE') {
            // æ‚¬æµ®å‘¼å¸æ•ˆæœ
            const time = Date.now() * 0.001;
            cardGroup.position.y += Math.sin(time) * 0.005;
            cardGroup.rotation.z = Math.sin(time * 0.5) * 0.1;
            
            // ç¼“æ…¢å›åˆ°ä¸­å¿ƒ (å¦‚æœæ²¡æœ‰è¢«æŠ“)
            cardGroup.position.lerp(new THREE.Vector3(0, 0, 0), 0.02);
            cardGroup.rotation.x *= 0.95;
            cardGroup.rotation.y *= 0.95;

            // æ£€æµ‹æŠ“å–
            if (pinchDistance < 0.06 && handPos.distanceTo(cardGroup.position) < 4) {
                cardState = 'GRABBED';
            }
            // æ£€æµ‹æ‹³å¤´æ‘§æ¯
            if (isFist && handPos.distanceTo(cardGroup.position) < 4) {
                triggerDestruction();
            }
        } else if (cardState === 'DESTROYED') {
            updateExplosion();
            respawnTimer++;
            if (respawnTimer > 100) triggerRespawn();
        }

        // 2. æ‹–å°¾æ›´æ–°
        updateTrail();

        lastHandPos.copy(handPos);
        renderer.render(scene, camera);
        
        // æ›´æ–° UI
        document.getElementById('state-text').innerText = `STATE: ${cardState}`;
    }

    // --- ç‰¹æ•ˆé€»è¾‘ ---
    function triggerDestruction() {
        if(cardState === 'DESTROYED') return;
        cardState = 'DESTROYED';
        cardGroup.visible = false;
        
        // åˆå§‹åŒ–çˆ†ç‚¸ç²’å­
        const center = cardGroup.position;
        const positions = pGeo.attributes.position.array;
        
        for(let i=0; i<particleCount; i++) {
            const idx = i*3;
            // ä»å¡ç‰Œä¸­å¿ƒå‘å°„
            pPos[idx] = center.x + (Math.random()-0.5)*2;
            pPos[idx+1] = center.y + (Math.random()-0.5)*3;
            pPos[idx+2] = center.z + (Math.random()-0.5)*0.5;
            
            // éšæœºé€Ÿåº¦
            pVel[idx] = (Math.random() - 0.5) * 0.5;
            pVel[idx+1] = (Math.random() - 0.5) * 0.5;
            pVel[idx+2] = (Math.random() - 0.5) * 0.5;
            
            pLife[i] = 1.0; // ç”Ÿå‘½å€¼æ»¡
        }
        pMat.opacity = 1;
        pGeo.attributes.position.needsUpdate = true;
        respawnTimer = 0;
    }

    function updateExplosion() {
        const positions = pGeo.attributes.position.array;
        let activeParticles = false;
        
        for(let i=0; i<particleCount; i++) {
            if(pLife[i] > 0) {
                const idx = i*3;
                positions[idx] += pVel[idx];
                positions[idx+1] += pVel[idx+1];
                positions[idx+2] += pVel[idx+2];
                
                // æ¨¡æ‹Ÿé‡åŠ›å’Œé˜»åŠ›
                pVel[idx+1] -= 0.005; 
                pVel[idx] *= 0.98;
                pVel[idx+1] *= 0.98;
                pVel[idx+2] *= 0.98;

                pLife[i] -= 0.01;
                activeParticles = true;
            }
        }
        pMat.opacity -= 0.01;
        pGeo.attributes.position.needsUpdate = true;
    }

    function triggerRespawn() {
        cardState = 'IDLE';
        cardGroup.visible = true;
        cardGroup.position.set(0, 0, -5); // ä»è¿œå¤„é£æ¥
        cardGroup.scale.set(0,0,0);
        
        // ç®€å•çš„å¼¹å…¥åŠ¨ç”»
        let s = 0;
        const popIn = setInterval(() => {
            s += 0.1;
            cardGroup.scale.set(s,s,s);
            if(s >= 1) clearInterval(popIn);
        }, 16);
    }

    function updateTrail() {
        // ç®€å•çš„é˜Ÿåˆ—ç§»åŠ¨ï¼Œå½¢æˆæ‹–å°¾
        const arr = trailGeo.attributes.position.array;
        for(let i = (trailSize-1)*3; i >= 3; i--) {
            arr[i] = arr[i-3];
        }
        arr[0] = handPos.x;
        arr[1] = handPos.y;
        arr[2] = handPos.z;
        trailGeo.attributes.position.needsUpdate = true;
    }

    // --- MediaPipe å¤„ç† ---
    const videoElement = document.getElementById('input-video');
    
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. è·å–æ‰‹æŒä¸­å¿ƒ (ç®€å•çš„å¹³å‡å€¼: è…•éƒ¨0, é£ŸæŒ‡æ ¹éƒ¨5, å°æŒ‡æ ¹éƒ¨17)
            const wrist = landmarks[0];
            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];
            
            // æ˜ å°„åˆ° Three.js åæ ‡ (-1 åˆ° 1 -> -x åˆ° x)
            // Z è½´ä¼°ç®—
            const depth = (1 - indexBase.z) * 10; 
            
            const x = (0.5 - indexBase.x) * 20; // å·¦å³åè½¬å¹¶ç¼©æ”¾
            const y = (0.5 - indexBase.y) * 15;
            // è®©æ‰‹åœ¨å›ºå®š Z å¹³é¢æ“ä½œï¼Œæˆ–è€…æ ¹æ®æ‰‹çš„å¤§å°åš Z è½´
            const z = 0; 

            // å¹³æ»‘ç§»åŠ¨
            handPos.lerp(new THREE.Vector3(x, y, z), 0.5);

            // 2. è®¡ç®—æ‰‹æŒæ—‹è½¬ (é€šè¿‡ä¸‰ä¸ªç‚¹çš„å¹³é¢)
            // ç®€åŒ–ç‰ˆï¼šåªéœ€è®¡ç®—æ‰‹æŒæ³•çº¿
            // è¿™é‡Œä¸ºäº†æ€§èƒ½å’Œç¨³å®šæ€§ï¼Œç®€å•æ ¹æ®æ‰‹è…•å’ŒæŒ‡æ ¹è®¡ç®— Roll/Pitch
            const v1 = new THREE.Vector3(indexBase.x - wrist.x, indexBase.y - wrist.y, indexBase.z - wrist.z);
            const v2 = new THREE.Vector3(pinkyBase.x - wrist.x, pinkyBase.y - wrist.y, pinkyBase.z - wrist.z);
            v1.normalize(); v2.normalize();
            
            // è®¡ç®—æ—‹è½¬å››å…ƒæ•°
            // è¿™é‡Œä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬è®©å¡ç‰Œæ­£é¢æœå‘æ‘„åƒå¤´ï¼Œä½†è·Ÿéšæ‰‹çš„å€¾æ–œ
            // å¦‚æœæƒ³è®©å¡ç‰Œå®Œå…¨ 1:1 è·Ÿéšæ‰‹æŒç¿»è½¬ï¼Œéœ€è¦å¤æ‚çš„çŸ©é˜µè®¡ç®—
            // ç®€æ˜“æ–¹æ¡ˆï¼šæ ¹æ®æ‰‹çš„X/Yä½ç§»ç¨å¾®å€¾æ–œï¼Œå¢åŠ åŠ¨æ€æ„Ÿ
            // è¿›é˜¶ï¼šå¦‚æœæ£€æµ‹åˆ°æ‰‹èƒŒï¼ˆlandmarks z é¡ºåºï¼‰ï¼Œç¿»è½¬å¡ç‰Œ
            
            // 3. æåˆæ£€æµ‹
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const d = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            pinchDistance = d; // é€šå¸¸ < 0.05 æ˜¯æåˆ

            // 4. æ¡æ‹³æ£€æµ‹ (ç®€å•çš„æŒ‡å°–åˆ°æ‰‹æŒæ ¹éƒ¨è·ç¦»æ£€æµ‹)
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
            isFist = palmDist < 0.15; // é˜ˆå€¼éœ€è°ƒè¯•

            // è®¡ç®—ä¸€ä¸ªå¤§è‡´çš„æ—‹è½¬è·Ÿéš
            const targetRot = new THREE.Quaternion();
            // è®©å¡ç‰Œç¨å¾®å‘æ‰‹çš„ç§»åŠ¨æ–¹å‘å€¾æ–œ
            targetRot.setFromEuler(new THREE.Euler(
                (indexBase.y - wrist.y) * -3, // Pitch
                (indexBase.x - wrist.x) * 3,  // Yaw
                (indexBase.x - wrist.x) * -2, // Roll
                'XYZ'
            ));
            handRot.slerp(targetRot, 0.1);

        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480, facingMode: "user"
    });
    cameraUtils.start();

    // åŠ¨ç”»å¯åŠ¨
    animate();

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
