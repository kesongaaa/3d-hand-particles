<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js é«˜èƒ½ç²’å­æ ¸å¿ƒ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ - å¢åŠ å‘å…‰è¾¹æ¡† */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 135px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            z-index: 10;
            background: #000;
        }
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  - æ›´é†’ç›® */
        #status-bar {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud-text {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 15px rgba(0, 200, 255, 1);
            letter-spacing: 2px;
            transition: all 0.2s;
        }

        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            z-index: 100;
            font-size: 20px;
        }
    </style>

    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div>âš¡ æ­£åœ¨å……èƒ½è§†è§‰æ ¸å¿ƒ...</div>
    </div>
    
    <div id="status-bar">
        <div id="gesture-text" class="hud-text">å‡†å¤‡å°±ç»ª</div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <!-- å¼•å…¥ Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½®: å¢å¼ºäº®åº¦å’Œå°ºå¯¸ ---
        const CONFIG = {
            particleCount: 20000, 
            bg: 0x000000 
        };

        let scene, camera, renderer, particleSystem;
        let positions, targetPositions, sizes;
        let currentGesture = 'NONE';
        
        // çŠ¶æ€å˜é‡
        let state = {
            expansion: 1.0,
            noiseStrength: 0.2,
            coreHeat: 0.0, // æ–°å¢ï¼šæ ¸å¿ƒçƒ­åº¦ï¼ˆæ”¹å˜é¢œè‰²ï¼‰
            rotationSpeed: 0.001
        };

        let targetState = { ...state };

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bg);
            // é›¾æ°”è°ƒæ·¡ï¼Œè®©è¿œå¤„ç²’å­æ›´æ¸…æ™°
            scene.fog = new THREE.FogExp2(CONFIG.bg, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50; // æ‹‰è¿œä¸€ç‚¹è§†è§’

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            createParticles();
            window.addEventListener('resize', onWindowResize);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.particleCount * 3);
            targetPositions = new Float32Array(CONFIG.particleCount * 3);
            sizes = new Float32Array(CONFIG.particleCount);
            
            // åˆå§‹å½¢çŠ¶ï¼šçƒä½“
            calculateShape('SPHERE');
            positions.set(targetPositions);

            // åˆå§‹å¤§å°ï¼šå¤§å¹…å¢åŠ åŸºç¡€å¤§å°
            for(let i=0; i<CONFIG.particleCount; i++) {
                sizes[i] = Math.random() * 1.5 + 0.5; // 0.5 ~ 2.0
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Shader: å¢å¼ºå‘å…‰æ„Ÿ
            constmaterial = new THREE.ShaderMaterial({
                uniforms: {
                    colorCore: { value: new THREE.Color(0xffffff) }, // æ ¸å¿ƒç™½
                    colorEdge: { value: new THREE.Color(0x0088ff) }, // è¾¹ç¼˜è“
                    pointTexture: { value: createGlowTexture() },
                    mixFactor: { value: 0.0 } // ç”¨äºå˜è‰²
                },
                vertexShader: `
                    attribute float size;
                    varying float vAlpha;
                    varying float vDist;
                    uniform float mixFactor;

                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // è·ç¦»è¶Šè¿‘ï¼Œç²’å­è¶Šå¤§ (ä» 300 æ”¹ä¸º 800ï¼Œæå¤§å¢å¼ºè§†è§‰ä½“ç§¯)
                        gl_PointSize = size * (800.0 / -mvPosition.z);
                        
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„è·ç¦»ï¼Œç”¨äºé¢œè‰²æ··åˆ
                        vDist = length(position);
                        
                        // åŸºç¡€é€æ˜åº¦
                        vAlpha = 1.0; 
                    }
                `,
                fragmentShader: `
                    uniform vec3 colorCore;
                    uniform vec3 colorEdge;
                    uniform sampler2D pointTexture;
                    uniform float mixFactor;
                    varying float vAlpha;
                    varying float vDist;

                    void main() {
                        // é¢œè‰²æ ¹æ®è·ç¦»æ’å€¼ï¼šä¸­å¿ƒäº®ç™½ï¼Œè¾¹ç¼˜æ·±è“
                        // mixFactor è¶Šé«˜ï¼Œæ•´ä½“è¶Šçº¢/çƒ­
                        vec3 finalColor = mix(colorEdge, colorCore, 1.0 - smoothstep(0.0, 30.0, vDist));
                        
                        // å¦‚æœå¤„äºé«˜èƒ½çŠ¶æ€(mixFactorå¤§)ï¼Œå åŠ ç«çº¢è‰²
                        finalColor = mix(finalColor, vec3(1.0, 0.2, 0.1), mixFactor * 0.8);

                        gl_FragColor = vec4(finalColor, vAlpha) * texture2D(pointTexture, gl_PointCoord);
                    }
                `,
                blending: THREE.AdditiveBlending, // å…³é”®ï¼šå åŠ æ··åˆï¼Œè¶Šå è¶Šäº®
                depthTest: false,
                transparent: true
            });

            particleSystem = new THREE.Points(geometry, constmaterial);
            scene.add(particleSystem);
        }

        // å½¢çŠ¶è®¡ç®—
        function calculateShape(type) {
            const arr = targetPositions;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (type === 'SPHERE' || type === 'FIST') {
                    // çƒä½“ï¼šä½†å¦‚æœFISTï¼Œæˆ‘ä»¬ä¼šåœ¨updateä¸­ç¼©æ”¾å®ƒï¼Œè¿™é‡Œåªç®¡å½¢çŠ¶
                    // å¢åŠ ä¸€äº›ä½“ç§¯æ„Ÿï¼ŒR=15
                    const r = 15 * Math.cbrt(Math.random()); 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (type === 'RING') {
                    // ç¯çŠ¶
                    const rMain = 18; 
                    const tube = 2;   
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    x = (rMain + tube * Math.cos(v)) * Math.cos(u);
                    y = (rMain + tube * Math.cos(v)) * Math.sin(u);
                    z = tube * Math.sin(v) * 2.0; // æ‹‰åšä¸€ç‚¹
                    
                    // æ”¾å°„çº¿
                    if (Math.random() > 0.9) {
                        x *= 1.5; y *= 1.5; z *= 5.0;
                    }
                }

                arr[i3] = x;
                arr[i3+1] = y;
                arr[i3+2] = z;
            }
        }

        function updateInteractionState() {
            // å¹³æ»‘è¿‡æ¸¡
            const lerpSpeed = 0.08;
            state.expansion += (targetState.expansion - state.expansion) * lerpSpeed;
            state.noiseStrength += (targetState.noiseStrength - state.noiseStrength) * lerpSpeed;
            state.coreHeat += (targetState.coreHeat - state.coreHeat) * lerpSpeed;

            // æ›´æ–° Shader é¢œè‰²å‚æ•°
            particleSystem.material.uniforms.mixFactor.value = state.coreHeat;
            
            const posAttr = particleSystem.geometry.attributes.position;
            const sizeAttr = particleSystem.geometry.attributes.size;
            const time = Date.now() * 0.001;

            for(let i=0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                const tx = targetPositions[i3];
                const ty = targetPositions[i3+1];
                const tz = targetPositions[i3+2];

                // å™ªç‚¹è®¡ç®—
                const noiseX = Math.sin(time * 2 + ty * 0.05) * state.noiseStrength;
                const noiseY = Math.cos(time * 2 + tx * 0.05) * state.noiseStrength;
                const noiseZ = Math.sin(time * 2 + i) * state.noiseStrength;

                // ä½ç½®æ›´æ–°
                posAttr.array[i3]     = tx * state.expansion + noiseX;
                posAttr.array[i3 + 1] = ty * state.expansion + noiseY;
                posAttr.array[i3 + 2] = tz * state.expansion + noiseZ;

                // åŠ¨æ€å¤§å°ï¼šæ ¸å¿ƒå¤„ç²’å­æ›´å¤§
                // å‘¼å¸æ•ˆæœ
                const pulse = 1.0 + Math.sin(time * 5) * 0.1;
                // æ³¨æ„ï¼šè¿™é‡Œä¸å†è®¾ç½®ä¸º0ï¼Œä¿è¯ç²’å­æ°¸è¿œå¯è§
                sizeAttr.array[i] = sizes[i] * pulse; 
            }

            posAttr.needsUpdate = true;
            sizeAttr.needsUpdate = true;
            
            // æ—‹è½¬é€Ÿåº¦éšçŠ¶æ€å˜åŒ– (èšèƒ½æ—¶æ—‹è½¬æ›´å¿«)
            const baseRot = 0.002;
            particleSystem.rotation.y += baseRot * (1 + state.coreHeat * 5.0);
        }

        // --- MediaPipe ---
        function initMediaPipe() {
            if (!window.Hands || !window.Camera) {
                setTimeout(initMediaPipe, 500);
                return;
            }

            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onHandResults);

            const cam = new window.Camera(document.getElementById('input-video'), {
                onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
                width: 320, height: 240
            });
            cam.start().then(() => {
                document.getElementById('loader').style.display = 'none';
            });
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const gesture = detectGesture(lm);
                if (gesture !== currentGesture) {
                    currentGesture = gesture;
                    applyGestureEffect(gesture);
                }
            } else {
                if (currentGesture !== 'NONE') {
                    currentGesture = 'NONE';
                    applyGestureEffect('NONE');
                }
            }
        }

        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            const tips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
            const dists = tips.map(tip => Math.sqrt(
                Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2) + Math.pow(tip.z - wrist.z, 2)
            ));

            const isFist = dists.every(d => d < 0.28); 
            if (isFist) return 'FIST';

            const indexExtended = dists[1] > 0.35; // ç¨å¾®æ”¾å®½ä¸€ç‚¹åˆ¤æ–­
            const othersCurled = dists[2] < 0.3 && dists[3] < 0.3 && dists[4] < 0.3;
            if (indexExtended && othersCurled) return 'POINT';

            const isOpen = dists.every(d => d > 0.3);
            if (isOpen) return 'OPEN';

            return 'NEUTRAL';
        }

        function applyGestureEffect(gesture) {
            const textEl = document.getElementById('gesture-text');
            
            switch(gesture) {
                case 'OPEN':
                    textEl.innerText = "ğŸ– çˆ†å‘æ¨¡å¼";
                    textEl.style.textShadow = "0 0 20px #00ffff";
                    textEl.style.color = "#fff";
                    
                    targetState.expansion = 2.8;      // ç‚¸å¾—æ›´å¼€
                    targetState.noiseStrength = 2.0;  // å‰§çƒˆæŠ–åŠ¨
                    targetState.coreHeat = 0.0;       // ä¿æŒè“è‰²
                    calculateShape('SPHERE'); 
                    break;

                case 'POINT':
                    textEl.innerText = "â˜ï¸ èƒ½é‡ç¯";
                    textEl.style.textShadow = "0 0 20px #ff00ff";
                    textEl.style.color = "#ffddff";

                    targetState.expansion = 1.0;
                    targetState.noiseStrength = 0.2;
                    targetState.coreHeat = 0.5;       // å¾®å¾®å‘ç´«
                    calculateShape('RING'); 
                    break;

                case 'FIST':
                    textEl.innerText = "âœŠ æ ¸å¿ƒèšèƒ½";
                    textEl.style.textShadow = "0 0 20px #ff4400";
                    textEl.style.color = "#ffaa00";

                    // å…³é”®ä¿®æ”¹ï¼šä¸å†æ˜¯æ¶ˆæ•£ï¼Œè€Œæ˜¯å˜æˆé«˜äº®æ ¸å¿ƒ
                    targetState.expansion = 0.3;      // ç´§å¯†èšåˆ
                    targetState.noiseStrength = 0.5;  // é«˜é¢‘æŒ¯åŠ¨
                    targetState.coreHeat = 1.0;       // å˜çº¢/å˜äº®
                    calculateShape('FIST');
                    break;

                default: 
                    textEl.innerText = "ç­‰å¾…æŒ‡ä»¤...";
                    textEl.style.textShadow = "0 0 10px #0088ff";
                    textEl.style.color = "#ddd";

                    targetState.expansion = 1.2;      // é»˜è®¤ç¨å¤§ä¸€ç‚¹
                    targetState.noiseStrength = 0.3;
                    targetState.coreHeat = 0.0;
                    calculateShape('SPHERE');
                    break;
            }
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; // è´´å›¾åˆ†è¾¨ç‡åŠ å¤§
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            // æ ¸å¿ƒæ›´ç™½ï¼Œè¾¹ç¼˜æ›´ç¡¬ä¸€ç‚¹ï¼Œé˜²æ­¢å¤ªç³Š
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(200, 240, 255, 0.8)');
            grad.addColorStop(0.6, 'rgba(0, 100, 255, 0.2)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateInteractionState();
            renderer.render(scene, camera);
        }

        initScene();
        initMediaPipe();
        animate();

    </script>
</body>
</html>
