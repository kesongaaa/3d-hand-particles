<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mystic Tarot - Three.js & MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Georgia', serif; color: #d4af37; user-select: none; -webkit-user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-feed { position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; z-index: 2; opacity: 0.8; border: 1px solid #d4af37; transform: scaleX(-1); display: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* Loading */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-shadow: 0 0 10px #d4af37; transition: opacity 0.5s; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px; pointer-events: auto;}
        
        /* Control Panel */
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; }
        .btn { background: rgba(0, 0, 0, 0.7); border: 1px solid #d4af37; color: #d4af37; padding: 10px 20px; cursor: pointer; font-family: serif; text-transform: uppercase; transition: 0.3s; }
        .btn:hover { background: #d4af37; color: #000; }
        .btn:active { transform: scale(0.95); }

        /* Card Meaning Overlay */
        #meaning-panel { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 500px; text-align: center; background: rgba(0,0,0,0.85); border: 1px solid #d4af37; padding: 20px; display: none; pointer-events: auto; }
        #card-title { font-size: 1.5em; margin-bottom: 10px; color: #fff; }
        #card-desc { font-size: 1em; line-height: 1.4; color: #ccc; }
        #gesture-hint { font-size: 0.8em; color: #d4af37; margin-top: 10px; font-style: italic; }

        /* History Sidebar */
        #history-panel { position: absolute; top: 0; left: 0; width: 200px; height: 100%; background: rgba(0,0,0,0.9); border-right: 1px solid #444; transform: translateX(-100%); transition: transform 0.3s; overflow-y: auto; pointer-events: auto; padding: 10px; box-sizing: border-box; }
        #history-panel.open { transform: translateX(0); }
        .history-item { border-bottom: 1px solid #333; padding: 10px 0; font-size: 0.9em; }
        .history-name { color: #fff; font-weight: bold; }
        .history-status { font-size: 0.8em; color: #aaa; }
        .history-reversed { color: #ff6b6b; }
        
        /* Toggle History Button */
        #history-btn { position: absolute; top: 10px; left: 10px; pointer-events: auto; z-index: 20; }
        
        /* Mode Indicator */
        #mode-indicator { position: absolute; top: 10px; right: 140px; font-size: 12px; color: #aaa; text-align: right; }
        
        /* Cursor for Hand Tracking */
        #hand-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%); display: none; pointer-events: none; z-index: 100; transition: border-color 0.2s; box-shadow: 0 0 5px #00ff00; }
        #hand-cursor.pinching { border-color: #00ffff; background: rgba(0,255,255,0.2); width: 15px; height: 15px; }
        #hand-cursor.fist { border-color: #ff0000; background: rgba(255,0,0,0.5); width: 30px; height: 30px; }

    </style>
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br><span style="font-size:14px">è¯·å…è®¸æ‘„åƒå¤´æƒé™æˆ–ç‚¹å‡»åˆ‡æ¢æ¨¡å¼</span></div>
    
    <div id="canvas-container"></div>
    <video id="input_video" playsinline></video>
    <div id="hand-cursor"></div>

    <div id="ui-layer">
        <button id="history-btn" class="btn" onclick="toggleHistory()">ğŸ“œ å†å²è®°å½•</button>
        <div id="mode-indicator">æ¨¡å¼: åˆå§‹åŒ–...</div>

        <div id="meaning-panel">
            <div id="card-title"></div>
            <div id="card-desc"></div>
            <div id="gesture-hint">æ‰‹åŠ¿ï¼šæ¡æ‹³ [FIST] ç¡®è®¤å¹¶åœ¨ç«ç„°ä¸­é‡Šæ”¾</div>
            <!-- Mobile Fallback Button -->
            <button id="mobile-confirm-btn" class="btn" style="margin-top:10px; display:none;" onclick="triggerBurn()">ç¡®è®¤å¹¶é‡Šæ”¾</button>
        </div>

        <div id="controls">
            <button class="btn" onclick="toggleMode()">ğŸ– / ğŸ–±ï¸ åˆ‡æ¢æ¨¡å¼</button>
            <button class="btn" onclick="resetGame()">ğŸ”„ é‡ç½®ç‰Œå †</button>
        </div>

        <div id="history-panel">
            <h3 style="color:#d4af37; border-bottom:1px solid #d4af37; padding-bottom:5px;">æŠ½å¡è®°å½•</h3>
            <div id="history-list"></div>
        </div>
    </div>

<script>
/**
 * å¡”ç½—ç‰Œæ•°æ® (Major Arcana Demo Data - can be expanded)
 * ä½¿ç”¨ GitHub Raw ä½œä¸ºå›¾æº
 */
const TAROT_DATA = [
    { id: 0, name: "The Fool", img: "ar00.jpg", up: "æ–°çš„å¼€å§‹ï¼Œå†’é™©ï¼Œçº¯çœŸï¼Œè‡ªå‘æ€§ã€‚", rev: "é²è½ï¼Œå†’é™©ï¼Œè¢«åˆ©ç”¨ï¼Œæ„šè ¢ã€‚" },
    { id: 1, name: "The Magician", img: "ar01.jpg", up: "æ„å¿—åŠ›ï¼Œæ¬²æœ›ï¼Œåˆ›é€ åŠ›ï¼Œæ˜¾åŒ–ã€‚", rev: "æ¬ºéª—ï¼Œå¹»è§‰ï¼Œæ„å›¾ä¸æ˜ã€‚" },
    { id: 2, name: "The High Priestess", img: "ar02.jpg", up: "ç›´è§‰ï¼Œæ½œæ„è¯†ï¼Œå†…åœ¨å£°éŸ³ã€‚", rev: "å‹æŠ‘æ„Ÿæƒ…ï¼Œç¼ºä¹è¿œè§ï¼Œç§˜å¯†ã€‚" },
    { id: 3, name: "The Empress", img: "ar03.jpg", up: "æ¯æ€§ï¼Œä¸°é¥¶ï¼Œè‡ªç„¶ï¼Œæ„Ÿå®˜äº«å—ã€‚", rev: "ä¾èµ–ï¼Œåˆ›é€ åŠ›å—é˜»ï¼Œç©ºè™šã€‚" },
    { id: 4, name: "The Emperor", img: "ar04.jpg", up: "æƒå¨ï¼Œç»“æ„ï¼Œæ§åˆ¶ï¼Œçˆ¶æ€§ã€‚", rev: "æš´æ”¿ï¼ŒåƒµåŒ–ï¼Œå†·é…·ï¼Œç¼ºä¹çºªå¾‹ã€‚" },
    { id: 5, name: "The Hierophant", img: "ar05.jpg", up: "ä¼ ç»Ÿï¼Œä¸€è‡´æ€§ï¼Œé“å¾·ï¼Œæ•™è‚²ã€‚", rev: "åå›ï¼Œé¢ è¦†ï¼Œæ–°çš„æ–¹æ³•ã€‚" },
    { id: 6, name: "The Lovers", img: "ar06.jpg", up: "ä¼™ä¼´å…³ç³»ï¼Œç»“åˆï¼ŒäºŒå…ƒæ€§ï¼Œé€‰æ‹©ã€‚", rev: "ä¸å’Œè°ï¼Œä¸å¹³è¡¡ï¼Œä»·å€¼è§‚å†²çªã€‚" },
    { id: 7, name: "The Chariot", img: "ar07.jpg", up: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼Œèƒœåˆ©ï¼Œæ–­è¨€ã€‚", rev: "ç¼ºä¹æ§åˆ¶ï¼Œä¾µç•¥ï¼Œæ–¹å‘è¿·å¤±ã€‚" },
    { id: 8, name: "Strength", img: "ar08.jpg", up: "å‹‡æ°”ï¼Œè€å¿ƒï¼Œæ§åˆ¶ï¼ŒåŒæƒ…ã€‚", rev: "è‡ªæˆ‘æ€€ç–‘ï¼Œè½¯å¼±ï¼Œä¸å®‰å…¨æ„Ÿã€‚" },
    { id: 9, name: "The Hermit", img: "ar09.jpg", up: "åçœï¼Œå¯»æ‰¾çœŸç†ï¼Œå†…åœ¨æŒ‡å¼•ã€‚", rev: "å­¤ç‹¬ï¼Œå­¤ç«‹ï¼Œè¿·å¤±ã€‚" },
    { id: 10, name: "Wheel of Fortune", img: "ar10.jpg", up: "æ”¹å˜ï¼Œå‘¨æœŸï¼Œå‘½è¿ï¼Œè½¬æŠ˜ç‚¹ã€‚", rev: "è¿æ°”ä¸å¥½ï¼Œé˜»åŠ›ï¼Œæ‰“ç ´å¾ªç¯ã€‚" },
    // ä¸ºäº†æ¼”ç¤ºï¼Œä»…åˆ—å‡ºéƒ¨åˆ†å¤§é˜¿å¡çº³ã€‚å®é™…åº”ç”¨å¯æ‰©å±•è‡³78å¼ ã€‚
];
// å¡«å……å‰©ä½™å¡ç‰Œä»¥å…æŠ¥é”™ï¼Œä½¿ç”¨é€šç”¨å ä½
for(let i=11; i<78; i++) {
    TAROT_DATA.push({
        id: i, 
        name: `Card ${i}`, 
        img: "ar00.jpg", // Fallback to Fool
        up: "é€šç”¨æ­£ä½å«ä¹‰...", 
        rev: "é€šç”¨é€†ä½å«ä¹‰..."
    });
}

const IMG_BASE_URL = "https://raw.githubusercontent.com/tinder-jackson/tarot-images/main/images/";
const BACK_IMG_URL = "https://i.imgur.com/P40A9qB.jpg"; // é€šç”¨ç‰ŒèƒŒ

// å…¨å±€å˜é‡
let scene, camera, renderer, raycaster;
let mouse = new THREE.Vector2();
let cursorPosition = { x: 0, y: 0 }; // å½’ä¸€åŒ–åæ ‡
let isHandMode = true;
let hands, cameraUtils;
let deckGroup = new THREE.Group();
let particles = [];
let drawnCards = []; // ç´¢å¼•
let currentCard = null; // å½“å‰æ­£åœ¨æŠ½å–çš„ mesh
let state = 'IDLE'; // IDLE, HOVER, GRABBING, REVEALED, BURNING
let handState = 'OPEN'; // OPEN, PINCH, FIST
let pinchStartPos = new THREE.Vector3();
let cardStartPos = new THREE.Vector3();
let history = [];

// Three.js åˆå§‹åŒ–
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x111111, 0.05);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 3, 6);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);
    
    const spotLight = new THREE.SpotLight(0xff4400, 1.5, 10, Math.PI/4, 0.5, 1);
    spotLight.position.set(0, 5, 0);
    spotLight.target.position.set(0, 0, 0);
    scene.add(spotLight);
    scene.add(spotLight.target);

    // ç‰Œå † (è§†è§‰å‡è±¡ï¼Œå®é™…æŠ½å¡æ˜¯ç”Ÿæˆæ–°mesh)
    createDeckVisuals();
    
    // å°„çº¿
    raycaster = new THREE.Raycaster();

    window.addEventListener('resize', onWindowResize, false);
    
    // é¼ æ ‡äº‹ä»¶ (Fallback)
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);
    
    animate();
}

function createDeckVisuals() {
    // åˆ›å»ºä¸€ä¸ªç®€å•çš„ç‰Œå †æ¨¡å‹
    const geometry = new THREE.BoxGeometry(1.5, 0.2, 2.5);
    const material = new THREE.MeshStandardMaterial({ 
        color: 0x3a2010, 
        roughness: 0.7 
    });
    
    // ç‰ŒèƒŒçº¹ç†
    new THREE.TextureLoader().load(BACK_IMG_URL, (tex) => {
        material.map = tex;
        material.needsUpdate = true;
    });

    const deckMesh = new THREE.Mesh(geometry, material);
    deckMesh.position.set(0, 0, 0);
    deckMesh.castShadow = true;
    deckMesh.receiveShadow = true;
    deckMesh.name = "DECK";
    
    deckGroup.add(deckMesh);
    scene.add(deckGroup);
}

// æŠ½å¡é€»è¾‘
function spawnCard() {
    if (drawnCards.length >= TAROT_DATA.length) {
        alert("ç‰Œåº“å·²ç©ºï¼è¯·é‡ç½®ã€‚");
        return;
    }

    // éšæœºæŠ½é€‰
    let cardIndex;
    do {
        cardIndex = Math.floor(Math.random() * TAROT_DATA.length);
    } while (drawnCards.includes(cardIndex));
    
    drawnCards.push(cardIndex);
    const cardData = TAROT_DATA[cardIndex];
    const isReversed = Math.random() < 0.5;

    // åˆ›å»ºå¡ç‰Œ Mesh
    const geometry = new THREE.PlaneGeometry(1.5, 2.5);
    // æè´¨ï¼šæ­£é¢å’ŒèƒŒé¢
    const matBack = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const matFront = new THREE.MeshStandardMaterial({ color: 0xcccccc }); // åŠ è½½å‰å ä½
    
    // åŠ è½½çº¹ç†
    const loader = new THREE.TextureLoader();
    loader.load(BACK_IMG_URL, (tex) => { matBack.map = tex; matBack.needsUpdate = true; });
    loader.load(IMG_BASE_URL + cardData.img, (tex) => { matFront.map = tex; matFront.needsUpdate = true; });

    // ç»„åˆæ­£åé¢ (Group æˆ–è€… Double Sided Planeï¼Œä¸ºäº†ç®€å•ç”¨ä¸¤ä¸ªPlaneèƒŒå¯¹èƒŒ)
    const cardGroup = new THREE.Group();
    
    const backMesh = new THREE.Mesh(geometry, matBack);
    backMesh.rotation.y = Math.PI; // èƒŒé¢æœå‘æ‘„åƒæœº
    backMesh.position.z = 0.01;
    
    const frontMesh = new THREE.Mesh(geometry, matFront);
    frontMesh.position.z = -0.01;
    // å¦‚æœé€†ä½ï¼Œæ­£é¢çº¹ç†æ—‹è½¬180
    if (isReversed) {
        frontMesh.rotation.z = Math.PI;
    }

    cardGroup.add(backMesh);
    cardGroup.add(frontMesh);
    
    // åˆå§‹ä½ç½®åœ¨ç‰Œå †ä¸Šæ–¹
    cardGroup.position.set(0, 0.5, 0);
    cardGroup.rotation.x = -Math.PI / 2; // å¹³æ”¾
    cardGroup.userData = { 
        id: cardIndex, 
        data: cardData, 
        reversed: isReversed,
        velocity: new THREE.Vector3()
    };
    
    scene.add(cardGroup);
    currentCard = cardGroup;
    state = 'GRABBING'; // ç›´æ¥è¿›å…¥æŠ“å–çŠ¶æ€
    
    // UI æ›´æ–°
    updateUIForCard(cardData, isReversed);
}

function updateUIForCard(data, isReversed) {
    const title = document.getElementById('card-title');
    const desc = document.getElementById('card-desc');
    const panel = document.getElementById('meaning-panel');
    const btn = document.getElementById('mobile-confirm-btn');
    
    title.innerHTML = `${data.name} <span style="font-size:0.6em; color:${isReversed?'#ff6b6b':'#00ff00'}">(${isReversed ? 'é€†ä½' : 'æ­£ä½'})</span>`;
    desc.innerText = isReversed ? data.rev : data.up;
    panel.style.display = 'block';
    
    // å¦‚æœæ˜¯é¼ æ ‡æ¨¡å¼ï¼Œæ˜¾ç¤ºæŒ‰é’®
    if (!isHandMode) btn.style.display = 'inline-block';
    else btn.style.display = 'none';
}

function triggerBurn() {
    if (state !== 'REVEALED' || !currentCard) return;
    
    state = 'BURNING';
    
    // æ·»åŠ åˆ°å†å²
    addToHistory(currentCard.userData);
    
    // åˆ›å»ºç²’å­
    createAshEffect(currentCard);
    
    // éšè—/ç§»é™¤å¡ç‰Œ
    scene.remove(currentCard);
    currentCard = null;
    
    // éšè— UI
    document.getElementById('meaning-panel').style.display = 'none';
    
    // é‡ç½®çŠ¶æ€
    setTimeout(() => {
        state = 'IDLE';
    }, 1000);
}

// ç°çƒ¬ç²’å­ç‰¹æ•ˆ
function createAshEffect(cardMesh) {
    const particleCount = 800;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    const colors = [];
    const sizes = [];
    
    const cardPos = cardMesh.position.clone();
    // ç®€å•çš„åˆ†å¸ƒåœ¨å¡ç‰ŒåŒºåŸŸ
    for (let i = 0; i < particleCount; i++) {
        // éšæœºåˆ†å¸ƒåœ¨ 1.5 x 2.5 çš„åŒºåŸŸ
        const x = (Math.random() - 0.5) * 1.5 + cardPos.x;
        const y = (Math.random() - 0.5) * 2.5 + cardPos.y;
        const z = cardPos.z + (Math.random() - 0.5) * 0.1;
        
        positions.push(x, y, z);
        
        // å‘ä¸Šé£˜ï¼Œå¸¦ä¸€ç‚¹éšæœºæ‰°åŠ¨
        velocities.push(
            (Math.random() - 0.5) * 0.05, // vx
            Math.random() * 0.1 + 0.02,   // vy (up)
            (Math.random() - 0.5) * 0.05  // vz
        );
        
        // é‡‘è‰²åˆ°ç°è‰²æ¸å˜
        const color = new THREE.Color();
        if (Math.random() > 0.5) color.setHex(0xffd700);
        else color.setHex(0x555555);
        colors.push(color.r, color.g, color.b);
        
        sizes.push(Math.random() * 0.15);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    
    const material = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 1,
        depthWrite: false
    });
    
    const points = new THREE.Points(geometry, material);
    points.userData = {
        velocities: velocities,
        life: 1.0
    };
    
    scene.add(points);
    particles.push(points);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.userData.life -= 0.015;
        p.material.opacity = p.userData.life;
        
        const positions = p.geometry.attributes.position.array;
        const vels = p.userData.velocities;
        
        for (let j = 0; j < positions.length; j += 3) {
            // æ¹æµæ¨¡æ‹Ÿ
            const noise = Math.sin(positions[j+1] * 5) * 0.01;
            
            positions[j] += vels[j] + noise;
            positions[j+1] += vels[j+1];
            positions[j+2] += vels[j+2];
            
            // ç²’å­ç¼©å°
            // positions[j] scale logic could go here if using size attr update
        }
        
        p.geometry.attributes.position.needsUpdate = true;
        
        if (p.userData.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
}

// MediaPipe Hands è®¾ç½®
function initMediaPipe() {
    const video = document.getElementById('input_video');
    
    hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    
    hands.onResults(onHandsResults);
    
    // å°è¯•å¯åŠ¨æ‘„åƒå¤´
    const cameraFeed = new Camera(video, {
        onFrame: async () => {
            await hands.send({image: video});
        },
        width: 320,
        height: 240
    });
    
    cameraFeed.start()
        .then(() => {
            console.log("Camera started");
            document.getElementById('loading').style.display = 'none';
            document.getElementById('mode-indicator').innerText = "æ¨¡å¼: æ‰‹åŠ¿è¿½è¸ª (Open/Pinch/Fist)";
            document.getElementById('video-feed').style.display = 'block';
        })
        .catch(err => {
            console.error("Camera failed", err);
            fallbackToMouse();
        });
}

function fallbackToMouse() {
    isHandMode = false;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('mode-indicator').innerText = "æ¨¡å¼: é¼ æ ‡/è§¦æ‘¸";
    document.getElementById('video-feed').style.display = 'none';
    document.getElementById('hand-cursor').style.display = 'none';
    
    // å¦‚æœå½“å‰æœ‰å¡ï¼Œæ˜¾ç¤ºç¡®è®¤æŒ‰é’®
    if (state === 'REVEALED') {
        document.getElementById('mobile-confirm-btn').style.display = 'inline-block';
    }
}

function onHandsResults(results) {
    if (!isHandMode) return;
    
    const cursor = document.getElementById('hand-cursor');
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. è®¡ç®—æ‰‹æŒä¸­å¿ƒæˆ–é£ŸæŒ‡ä½ç½®æ˜ å°„åˆ°å±å¹• (Mirror X)
        // MediaPipe coords: x [0,1] left->right, y [0,1] top->bottom
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        const wrist = landmarks[0];

        // æ˜ å°„åæ ‡ (é•œåƒX)
        const x = (1 - indexTip.x) * window.innerWidth;
        const y = indexTip.y * window.innerHeight;
        
        cursorPosition.x = ( (1 - indexTip.x) * 2 ) - 1;
        cursorPosition.y = - ( indexTip.y * 2 ) + 1;
        
        // æ›´æ–° cursor DOM
        cursor.style.display = 'block';
        cursor.style.left = x + 'px';
        cursor.style.top = y + 'px';
        
        // 2. æ‰‹åŠ¿è¯†åˆ«
        // è®¡ç®—è·ç¦»
        const distPinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        const distFist1 = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
        const distFist2 = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
        const distOpen = Math.hypot(middleTip.y - wrist.y, middleTip.x - wrist.x); // rough measure

        let newState = 'OPEN';
        
        // é˜ˆå€¼è°ƒæ•´ (æ ¹æ®å®é™…æµ‹è¯•å¾®è°ƒ)
        if (distPinch < 0.05) {
            newState = 'PINCH';
        } else if (distFist1 < 0.15 && distFist2 < 0.15 && distPinch < 0.1) {
            // æ‰€æœ‰æ‰‹æŒ‡å·æ›²
            newState = 'FIST';
        } 
        
        handState = newState;
        
        // Cursor æ ·å¼
        cursor.className = newState.toLowerCase();
        
    } else {
        cursor.style.display = 'none';
    }
}

// æ¸¸æˆä¸»å¾ªç¯é€»è¾‘
function updateGameLogic() {
    // å°„çº¿æ£€æµ‹
    raycaster.setFromCamera(new THREE.Vector2(cursorPosition.x, cursorPosition.y), camera);
    
    if (state === 'IDLE') {
        const intersects = raycaster.intersectObjects([deckGroup], true);
        if (intersects.length > 0) {
            document.body.style.cursor = 'pointer';
            
            // æ‰‹åŠ¿è§¦å‘æŠ½å¡
            if ((isHandMode && handState === 'PINCH') || (!isHandMode && mouse.isDown)) {
                spawnCard();
            }
        } else {
            document.body.style.cursor = 'default';
        }
    }
    else if (state === 'GRABBING') {
        if (!currentCard) return;

        // è®©å¡ç‰Œè·Ÿéšå…‰æ ‡ï¼Œä½†åœ¨å‰æ–¹ä¸€å®šè·ç¦»
        const targetPos = new THREE.Vector3();
        // åœ¨ç›¸æœºå‰æ–¹ 3 å•ä½å¤„
        const vector = new THREE.Vector3(cursorPosition.x, cursorPosition.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = 4; // æ‚¬åœè·ç¦»
        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
        
        // å¹³æ»‘ç§»åŠ¨
        currentCard.position.lerp(pos, 0.1);
        
        // æ—‹è½¬å¡ç‰Œé¢å‘ç›¸æœº (ç¨å¾®å€¾æ–œ)
        currentCard.lookAt(camera.position);
        
        // ç¿»è½¬é€»è¾‘ï¼šå½“å¡ç‰Œæ¥è¿‘å±å¹•ä¸­å¿ƒæ—¶ç¿»è½¬
        if (Math.abs(cursorPosition.x) < 0.2 && Math.abs(cursorPosition.y) < 0.2) {
             // ç¿»è½¬æ˜¾ç¤ºæ­£é¢
             // åŸæœ¬æ˜¯ PlaneBack èƒŒå¯¹ç›¸æœºï¼ŒPlaneFront æœå‘é‡Œé¢
             // éœ€è¦è®© PlaneFront æœå‘ç›¸æœº
             // åˆå§‹: cardGroup.lookAt(camera). Back is visible.
             // Target: Rotate X/Y to show Front.
             
             // è¿™é‡Œç®€åŒ–ï¼šç›´æ¥ç¿»è½¬180åº¦
             const targetRot = new THREE.Quaternion();
             targetRot.setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
             // å®é™…ä¸Š lookAt å·²ç»é”å®šäº†æœå‘ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ Group å†…éƒ¨æ—‹è½¬æˆ–è€…æ”¹å˜çŠ¶æ€
             // ç®€å•å¤„ç†ï¼šçŠ¶æ€æ”¹å˜
             state = 'REVEALED';
        }
    }
    else if (state === 'REVEALED') {
        if (!currentCard) return;
        
        // æ‚¬åœåœ¨å±å¹•ä¸­å¿ƒ
        const centerPos = new THREE.Vector3(0, 0, -3).applyMatrix4(camera.matrixWorld); // ç›¸æœºå‰æ–¹3ç±³
        currentCard.position.lerp(centerPos, 0.05);
        
        // æŒç»­æœå‘ç›¸æœº
        currentCard.lookAt(camera.position);
        // å› ä¸ºæ¨¡å‹æ„é€ æ˜¯ Back 0 rotation, Front åœ¨èƒŒé¢ï¼Œæ‰€ä»¥è¦ç»•Yè½¬180è®©æ­£é¢æœå‰
        currentCard.rotateY(Math.PI);
        
        // æ£€æŸ¥ Fist ç¡®è®¤
        if (isHandMode && handState === 'FIST') {
            triggerBurn();
        }
    }
}

// åŠ¨ç”»å¾ªç¯
function animate() {
    requestAnimationFrame(animate);
    
    updateGameLogic();
    updateParticles();
    
    renderer.render(scene, camera);
}

// äº¤äº’äº‹ä»¶å¤„ç†
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onMouseMove(event) {
    if (isHandMode) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    cursorPosition.x = mouse.x;
    cursorPosition.y = mouse.y;
}

function onMouseDown() {
    if (isHandMode) return;
    mouse.isDown = true;
}

function onMouseUp() {
    if (isHandMode) return;
    mouse.isDown = false;
}

// UI åŠŸèƒ½
function toggleMode() {
    if (isHandMode) {
        // åˆ‡æ¢åˆ°é¼ æ ‡
        if (hands) hands.close();
        fallbackToMouse();
    } else {
        // å°è¯•åˆ‡æ¢å›æ‘„åƒå¤´
        isHandMode = true;
        document.getElementById('loading').style.display = 'block';
        document.getElementById('loading').innerText = "æ­£åœ¨é‡å¯æ‘„åƒå¤´...";
        initMediaPipe();
    }
}

function toggleHistory() {
    const p = document.getElementById('history-panel');
    p.classList.toggle('open');
}

function addToHistory(data) {
    history.push(data);
    const list = document.getElementById('history-list');
    const div = document.createElement('div');
    div.className = 'history-item';
    div.innerHTML = `
        <div class="history-name">${data.data.name}</div>
        <div class="history-status ${data.reversed?'history-reversed':''}">${data.reversed?'é€†ä½':'æ­£ä½'}</div>
    `;
    list.prepend(div);
}

function resetGame() {
    if (currentCard) {
        scene.remove(currentCard);
        currentCard = null;
    }
    state = 'IDLE';
    drawnCards = [];
    history = [];
    document.getElementById('history-list').innerHTML = '';
    document.getElementById('meaning-panel').style.display = 'none';
    alert("ç‰Œå †å·²æ´—ç‰Œé‡ç½®ã€‚");
}

// å¯åŠ¨
initThree();
initMediaPipe();

</script>
</body>
</html>
